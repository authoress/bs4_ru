
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Документация Beautiful Soup &#8212; документация bs4RU 0.0.1</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="prev" title="Welcome to bs4RUdocs’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="beautiful-soup">
<h1>Документация Beautiful Soup<a class="headerlink" href="#beautiful-soup" title="Ссылка на этот заголовок">¶</a></h1>
<img alt="&quot;Лакей Карась начал с того, что вытащил из-под мышки огромный конверт (чуть ли не больше его самого).&quot;" class="align-right" src="_images/6.1.jpg" />
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> это
библиотека Python для извлечения данных из файлов HTML и XML. Она работает
с вашим любимым парсером, чтобы дать вам естественные способы навигации,
поиска и изменения дерева разбора. Она обычно экономит программистам
часы и дни работы.</p>
<p>Эти инструкции иллюстрируют все основные функции Beautiful Soup 4
на примерах. Я покажу вам, для чего нужна библиотека, как она работает,
как её использовать, как заставить её делать то, что вы хотите, и что нужно делать, когда она
не оправдывает ваши ожидания.</p>
<p>Примеры в этой документации работают одинаково на Python 2.7
и Python 3.2.</p>
<p>Возможно, вы ищете документацию для <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup 3</a>.
Если это так, имейте в виду, что Beautiful Soup 3 больше не
развивается, и что поддержка этой версии будет прекращена
31 декабря 2020 года или немногим позже. Если вы хотите узнать о различиях между Beautiful Soup 3
и Beautiful Soup 4, см. <a href="#id58"><span class="problematic" id="id59">`Перенос кода на BS4`_</span></a>.</p>
<p>Эта документация была переведена на другие языки
пользователями Beautiful Soup:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">这篇文档当然还有中文版.</a></p></li>
<li><p>このページは日本語で利用できます(<a class="reference external" href="http://kondou.com/BS4/">外部リンク</a>)</p></li>
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/">이 문서는 한국어 번역도 가능합니다.</a></p></li>
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr/">Este documento também está disponível em Português do Brasil.</a></p></li>
</ul>
<div class="section" id="id5">
<h2>Техническая поддержка<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если у вас есть вопросы о Beautiful Soup или у вас возникли проблемы,
<a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">отправьте письмо в дискуссионную группу</a>. Если
ваша проблема связана с разбором HTML-документа, не забудьте упомянуть,
<a class="reference internal" href="#diagnose"><span class="std std-ref">что говорит функция diagnose()</span></a> о
вашем документе.</p>
</div>
</div>
<div class="section" id="id7">
<h1>Быстрый старт<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h1>
<p>Вот HTML-документ, который я буду использовать в качестве примера в этой
документации. Это фрагмент из <cite>«Алисы в стране чудес»</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Прогон документа через Beautiful Soup дает нам
объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, который представляет документ в виде
вложенной структуры данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;title&gt;</span>
<span class="c1">#    The Dormouse&#39;s story</span>
<span class="c1">#   &lt;/title&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p class=&quot;title&quot;&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     The Dormouse&#39;s story</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#     Elsie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ,</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#     Lacie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    and</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span>
<span class="c1">#     Tillie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ; and they lived at the bottom of a well.</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    ...</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Вот несколько простых способов навигации по этой структуре данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;head&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Одна из распространенных задач - извлечь все URL-адреса, найденные на странице в тегах &lt;a&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;href&#39;</span><span class="p">))</span>
<span class="c1"># http://example.com/elsie</span>
<span class="c1"># http://example.com/lacie</span>
<span class="c1"># http://example.com/tillie</span>
</pre></div>
</div>
<p>Другая распространенная задача - извлечь весь текст со страницы:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># Once upon a time there were three little sisters; and their names were</span>
<span class="c1"># Elsie,</span>
<span class="c1"># Lacie and</span>
<span class="c1"># Tillie;</span>
<span class="c1"># and they lived at the bottom of a well.</span>
<span class="c1">#</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>Это похоже на то, что вам нужно? Если так, продолжайте читать.</p>
</div>
<div class="section" id="id8">
<h1>Установка Beautiful Soup<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h1>
<p>Если вы используете последнюю версию Debian или Ubuntu Linux, вы можете
установите Beautiful Soup с помощью системы управления пакетами:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-bs4</kbd> (для Python 2)</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python3-bs4</kbd> (для Python 3)</p>
<p>Beautiful Soup 4 публикуется через PyPi, поэтому, если вы не можете установить его
с помощью системы управления пакетами, можно установить его с помощью <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> или
<code class="docutils literal notranslate"><span class="pre">pip</span></code>. Пакет называется <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>, и один и тот же пакет
работает как на Python 2, так и на Python 3. Убедитесь, что вы используете версию
<code class="docutils literal notranslate"><span class="pre">pip</span></code> или <code class="docutils literal notranslate"><span class="pre">easy_install</span></code>, предназначенную для вашей версии Python (их можно назвать
<code class="docutils literal notranslate"><span class="pre">pip3</span></code> и <code class="docutils literal notranslate"><span class="pre">easy_install3</span></code> соответственно, если вы используете Python 3).</p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install beautifulsoup4</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install beautifulsoup4</kbd></p>
<p>(<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> - это, скорее всего, <cite>не тот</cite> пакет, который вам нужен. Это
предыдущий основной релиз, <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup 3</a>. Многие программы используют
BS3, так что он все еще доступен, но если вы пишете новый код, вам
нужно установить <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>.)</p>
<p>Если у вас не установлены <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> или <code class="docutils literal notranslate"><span class="pre">pip</span></code>, вы можете
<a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/download/4.x/">скачать архив с исходным кодом Beautiful Soup 4</a> и
установить его с помощью <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>.</p>
<p><kbd class="kbd docutils literal notranslate">$ python setup.py install</kbd></p>
<p>Если ничего не помогает, лицензия на Beautiful Soup позволяет вам
упаковать библиотеку целиком вместе с вашим приложением. Вы можете скачать
tar-архив, скопировать из него в кодовую базу вашего приложения каталог <code class="docutils literal notranslate"><span class="pre">bs4</span></code>,
и использовать Beautiful Soup, не устанавливая его вообще.</p>
<p>Я использую Python 2.7 и Python 3.2 для разработки Beautiful Soup, но библиотека
должна работать и с более поздними версиями Python.</p>
<div class="section" id="id9">
<h2>Проблемы после установки<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h2>
<p>Beautiful Soup упакован как код Python 2. Когда вы устанавливаете его для
использования с Python 3, он автоматически конвертируется в код Python 3. Если
вы не устанавливаете библиотеку в виде пакета, код не будет сконвертирован. Были
также сообщения об установке неправильной версии на компьютерах с
Windows.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> «No module named HTMLParser», ваша
проблема в том, что вы используете версию кода на Python 2, работая под
Python 3.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> «No module named html.parser», ваша
проблема в том, что вы используете версию кода на Python 3, работая под
Python 2.</p>
<p>В обоих случаях лучше всего полностью удалить Beautiful
Soup  с вашей системы (включая любой каталог, созданный
при распаковке tar-архива) и запустить установку еще раз.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> «Invalid syntax» в строке
<code class="docutils literal notranslate"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span> <span class="pre">u'[document]'</span></code>, вам нужно конвертировать код из Python 2
в Python 3. Вы можете сделать это установив пакет:</p>
<p><kbd class="kbd docutils literal notranslate">$ python3 setup.py install</kbd></p>
<p>или вручную запустив Python-скрипт преобразования <code class="docutils literal notranslate"><span class="pre">2to3</span></code>
в каталоге <code class="docutils literal notranslate"><span class="pre">bs4</span></code>:</p>
<p><kbd class="kbd docutils literal notranslate">$ 2to3-3.2 -w bs4</kbd></p>
</div>
<div class="section" id="parser-installation">
<span id="id10"></span><h2>Установка парсера<a class="headerlink" href="#parser-installation" title="Ссылка на этот заголовок">¶</a></h2>
<p>Beautiful Soup поддерживает парсер HTML, включенный в стандартную библиотеку Python,
а также ряд сторонних парсеров на Python.
Одним из них является <a class="reference external" href="http://lxml.de/">парсер lxml</a>. В зависимости от ваших настроек,
вы можете установить lxml с помощью одной из следующих команд:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-lxml</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install lxml</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install lxml</kbd></p>
<p>Другой альтернативой является написанный исключительно на Python <a class="reference external" href="http://code.google.com/p/html5lib/">парсер html5lib</a>, который разбирает HTML таким же образом,
как это делает веб-браузер. В зависимости от ваших настроек, вы можете установить html5lib
с помощью одной из этих команд:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-html5lib</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install html5lib</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install html5lib</kbd></p>
<p>Эта таблица суммирует преимущества и недостатки каждого парсера:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 35%" />
<col style="width: 26%" />
<col style="width: 21%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Парсер</p></td>
<td><p>Типичное использование</p></td>
<td><p>Преимущества</p></td>
<td><p>Недостатки</p></td>
</tr>
<tr class="row-even"><td><p>html.parser от Python</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html.parser&quot;)</span></code></p></td>
<td><ul class="simple">
<li><p>Входит в комплект</p></li>
<li><p>Приличная скорость</p></li>
<li><p>Снисходительный (Начиная с
Python 2.7.3 и 3.2.)</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Не такой быстрый, как
lxml, менее снисходи-
тельный, чемhtml5lib.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>HTML-парсер в lxml</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;lxml&quot;)</span></code></p></td>
<td><ul class="simple">
<li><p>Очень быстрый</p></li>
<li><p>Снисходительный</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Внешняя зависимость
от C</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>XML-парсер в lxml</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;lxml-xml&quot;)</span></code>
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;xml&quot;)</span></code></p></td>
<td><ul class="simple">
<li><p>Очень быстрый</p></li>
<li><p>Единственный XML-парсер,
который сейчас поддерживается</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Внешняя зависимость
от C</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>html5lib</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html5lib&quot;)</span></code></p></td>
<td><ul class="simple">
<li><p>Extremely lenient</p></li>
<li><p>Parses pages the same way a
web browser does</p></li>
<li><p>Creates valid HTML5</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Very slow</p></li>
<li><p>External Python
dependency</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Я рекомендую по возможности установить и использовать lxml для быстродействия. Если вы
использование версии Python 2 более раннюю, чем 2.7.3, или версии Python 3
более раннюю, чем 3.2.2, <cite>необходимо</cite> установить lxml или
html5lib - встроенный в Python анализатор HTML просто недостаточно хорош в старых
версиях.</p>
<p>Обратите внимание, что если документ невалиден, различные парсеры будут генерировать
дерево Beautiful Soup для этого документа по-разному. Смотрите <a class="reference internal" href="#id51">Различия
между парсерами</a> для более подробной информации.</p>
</div>
</div>
<div class="section" id="id11">
<h1>Приготовление супа<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h1>
<p>Чтобы разобрать документ, передайте его в
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Вы можете передать строку или открытый дескриптор файла:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;index.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;html&gt;data&lt;/html&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Первым делом документ конвертируется в Unicode, а HTML-сущности
конвертируются в символы Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>BeautifulSoup(&quot;Sacré bleu!&quot;)
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;
</pre></div>
</div>
<p>Затем Beautiful Soup анализирует документ, используя лучший из доступных
парсеров. Библиотека будет использовать HTML-парсер, если вы явно не укажете,
что нужно использовать XML-парсер. (См. <a href="#id60"><span class="problematic" id="id61">`Разбор XML`_</span></a>.)</p>
</div>
<div class="section" id="id12">
<h1>Виды объектов<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h1>
<p>Beautiful Soup превращает сложный HTML-документ в сложное дерево
объектов Python. Но вам придется иметь дело только с четырьмя
<cite>видами</cite> объектов: <code class="docutils literal notranslate"><span class="pre">Tag</span></code>, <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
и <code class="docutils literal notranslate"><span class="pre">Comment</span></code>.</p>
<div class="section" id="tag">
<span id="id13"></span><h2><code class="docutils literal notranslate"><span class="pre">Tag</span></code><a class="headerlink" href="#tag" title="Ссылка на этот заголовок">¶</a></h2>
<p>Объект <code class="docutils literal notranslate"><span class="pre">Tag</span></code> соответствует тегу XML или HTML в исходном документе:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Tag&#39;&gt;</span>
</pre></div>
</div>
<p>У объекта Tag (далее «тег») много атрибутов и методов, и я расскажу о большинстве из них
в разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>. На данный момент наиболее
важными особенностями тега являются его имя (name) и атрибуты (attributes).</p>
<div class="section" id="id14">
<h3>Имя<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h3>
<p>У каждого тега есть имя, доступное как <code class="docutils literal notranslate"><span class="pre">.name</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;b&#39;</span>
</pre></div>
</div>
<p>Если вы измените имя тега, это изменение будет отражено в любой HTML-
разметке, созданной Beautiful Soup:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>Атрибуты<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h3>
<p>У тега может быть любое количество атрибутов. Тег <code class="docutils literal notranslate"><span class="pre">&lt;b</span>
<span class="pre">id</span> <span class="pre">=</span> <span class="pre">&quot;boldest&quot;&gt;</span></code> имеет атрибут «id», значение которого равно
«boldest». Вы можете получить доступ к атрибутам тега, обращаясь с тегом как
со словарем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;boldest&#39;</span>
</pre></div>
</div>
<p>Вы можете получить доступ к этому словарю напрямую как к <code class="docutils literal notranslate"><span class="pre">.attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">attrs</span>
<span class="c1"># {u&#39;id&#39;: &#39;boldest&#39;}</span>
</pre></div>
</div>
<p>Вы можете добавлять, удалять и изменять атрибуты тега. Опять же, это
делается путём обращения с тегом как со словарем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;b another-attribute=&quot;1&quot; id=&quot;verybold&quot;&gt;&lt;/b&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;&lt;/b&gt;</span>

<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># KeyError: &#39;id&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">))</span>
<span class="c1"># None</span>
</pre></div>
</div>
<div class="section" id="multivalue">
<span id="id16"></span><h4>Многозначные атрибуты<a class="headerlink" href="#multivalue" title="Ссылка на этот заголовок">¶</a></h4>
<p>В HTML 4 определено несколько атрибутов, которые могут иметь множество значений. В HTML 5
пара таких атрибутов удалена, но определено еще несколько. Самый распространённый из
многозначных атрибутов - это <code class="docutils literal notranslate"><span class="pre">class</span></code> (т. е. тег может иметь более
одного класса CSS). Среди прочих <code class="docutils literal notranslate"><span class="pre">rel</span></code>, <code class="docutils literal notranslate"><span class="pre">rev</span></code>, <code class="docutils literal notranslate"><span class="pre">accept-charset</span></code>,
<code class="docutils literal notranslate"><span class="pre">headers</span></code> и <code class="docutils literal notranslate"><span class="pre">accesskey</span></code>. Beautiful Soup представляет значение(я)
многозначного атрибута в виде списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&quot;body&quot;]</span>

<span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&quot;body&quot;, &quot;strikeout&quot;]</span>
</pre></div>
</div>
<p>Если атрибут <cite>выглядит</cite> так, будто он имеет более одного значения, но это не
многозначный атрибут, определенный какой-либо версией HTML-
стандарта, Beautiful Soup оставит атрибут как есть:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">id_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;my id&#39;</span>
</pre></div>
</div>
<p>Когда вы преобразовываете тег обратно в строку, несколько значений атрибута
объединяются:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rel_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span>
<span class="c1"># [&#39;index&#39;]</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;contents&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rel_soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Вы можете отключить объединение, передав <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span> <span class="pre">=</span> <span class="pre">None</span></code> в качестве
именованного аргумента в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">no_list_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">no_list_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">get_attribute_list</span></code>, того чтобы получить значение в виде списка,
независимо от того, является ли атрибут многозначным или нет:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get_attribute_list</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="c1"># [&quot;my id&quot;]</span>
</pre></div>
</div>
<p>Если вы разбираете документ как XML, многозначных атрибутов не будет:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>Опять же, вы можете поменять настройку, используя аргумент <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">class_is_multi</span><span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;*&#39;</span> <span class="p">:</span> <span class="s1">&#39;class&#39;</span><span class="p">}</span>
<span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="n">class_is_multi</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [u&#39;body&#39;, u&#39;strikeout&#39;]</span>
</pre></div>
</div>
<p>Вряд ли вам это понадобится, но если все-таки понадобится, руководствуйтесь значениями
по умолчанию. Они реализуют правила, описанные в спецификации HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.builder</span> <span class="kn">import</span> <span class="n">builder_registry</span>
<span class="n">builder_registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">DEFAULT_CDATA_LIST_ATTRIBUTES</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="navigablestring">
<h2><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code><a class="headerlink" href="#navigablestring" title="Ссылка на этот заголовок">¶</a></h2>
<p>Строка соответствует фрагменту текста в теге. Beautiful Soup
использует класс <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> для хранения этих фрагментов текста:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> похожа на строку Unicode в Python, не считая того,
что она также поддерживает некоторые функции, описанные в
разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>. Вы можете конвертировать
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> в строку Unicode с помощью <code class="docutils literal notranslate"><span class="pre">unicode</span> <span class="pre">()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unicode_string</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">unicode_string</span>
<span class="c1"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">unicode_string</span><span class="p">)</span>
<span class="c1"># &lt;type &#39;unicode&#39;&gt;</span>
</pre></div>
</div>
<p>Вы не можете редактировать строку непосредственно, но вы можете заменить одну строку
другой, используя <a class="reference internal" href="#replace-with"><span class="std std-ref">replace_with()</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="s2">&quot;No longer bold&quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> поддерживает большинство функций, описанных в
разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>, но
не все. В частности, поскольку строка не может ничего содержать (в том смысле,
в котором тег может содержать строку или другой тег), строки не поддерживают
атрибуты <code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.string</span></code> или метод <code class="docutils literal notranslate"><span class="pre">find()</span></code>.</p>
<p>Если вы хотите использовать <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> вне Beautiful Soup,
вам нужно вызвать метод <code class="docutils literal notranslate"><span class="pre">unicode()</span></code>, чтобы превратить ее в обычную для Python
строку Unicode. Если вы этого не сделаете, ваша строка будет тащить за собой
ссылку на все дерево разбора Beautiful Soup, даже когда вы
закончите использовать Beautiful Soup. Это большой расход памяти.</p>
</div>
<div class="section" id="beautifulsoup">
<h2><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code><a class="headerlink" href="#beautifulsoup" title="Ссылка на этот заголовок">¶</a></h2>
<p>Объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> представляет разобранный документ как единое
целое. В большинстве случаев вы можете рассматривать его как объект
﻿:ref:<cite>Tag</cite>. Это означает, что он поддерживает большинство методов, описанных
в разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>.</p>
<p>Вы также можете передать объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> в один из методов,
перечисленных в разделе <a class="reference internal" href="#id42">Изменение дерева</a>, по аналогии с передачей объекта <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>. Это
позволяет вам делать такие вещи, как объединение двух разобранных документов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;document&gt;&lt;content/&gt;INSERT FOOTER HERE&lt;/document&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="n">footer</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;footer&gt;Here&#39;s the footer&lt;/footer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;INSERT FOOTER HERE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">footer</span><span class="p">)</span>
<span class="c1"># u&#39;INSERT FOOTER HERE&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="c1"># &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="c1"># &lt;document&gt;&lt;content/&gt;&lt;footer&gt;Here&#39;s the footer&lt;/footer&gt;&lt;/document&gt;</span>
</pre></div>
</div>
<p>Поскольку объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> не соответствует действительному
HTML или XML-тегу, у него нет имени и атрибутов. Однако иногда
бывает полезно взглянуть на <code class="docutils literal notranslate"><span class="pre">.name</span></code>, поэтому ему было присвоено специальное «имя»
<code class="docutils literal notranslate"><span class="pre">.name</span></code> «[document]»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;[document]&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>Комментарии и другие специфичные строки<a class="headerlink" href="#id17" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag</span></code>, <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> и <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> охватывают почти
все, с чем вы столкнётесь в файле HTML или XML, но осталось
ещё немного. Наверное, единственный, о котором стоит подумать,
это комментарий:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="nb">type</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Comment&#39;&gt;</span>
</pre></div>
</div>
<p>Объект <code class="docutils literal notranslate"><span class="pre">Comment</span></code> - это просто особый тип <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">comment</span>
<span class="c1"># u&#39;Hey, buddy. Want to buy a used parser&#39;</span>
</pre></div>
</div>
<p>Но когда он появляется как часть HTML-документа, <code class="docutils literal notranslate"><span class="pre">Comment</span></code>
отображается со специальным форматированием:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;b&gt;</span>
<span class="c1">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span>
<span class="c1"># &lt;/b&gt;</span>
</pre></div>
</div>
<p>Beautiful Soup определяет классы для всего, что может появиться в
XML-документе: <code class="docutils literal notranslate"><span class="pre">CData</span></code>, <code class="docutils literal notranslate"><span class="pre">ProcessingInstruction</span></code>,
<code class="docutils literal notranslate"><span class="pre">Declaration</span></code> и <code class="docutils literal notranslate"><span class="pre">Doctype</span></code>. Как и <code class="docutils literal notranslate"><span class="pre">Comment</span></code>, эти классы
являются подклассами <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, которые добавляют что-то ещё к
строке Вот пример, который заменяет комментарий блоком
CDATA:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">CData</span>
<span class="n">cdata</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">&quot;A CDATA block&quot;</span><span class="p">)</span>
<span class="n">comment</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">cdata</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;b&gt;</span>
<span class="c1">#  &lt;![CDATA[A CDATA block]]&gt;</span>
<span class="c1"># &lt;/b&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id18">
<h1>Навигация по дереву<a class="headerlink" href="#id18" title="Ссылка на этот заголовок">¶</a></h1>
<p>Вернёмся к HTML-документу с фрагментом из «Алисы в стране чудес»::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Я буду использовать его в качестве примера, чтобы показать вам, как перейти от одной части
документа к другой.</p>
<div class="section" id="id19">
<h2>Проход сверху вниз<a class="headerlink" href="#id19" title="Ссылка на этот заголовок">¶</a></h2>
<p>Теги могут содержать строки и другие теги. Эти элементы являются
дочерними (<cite>children</cite>) для тега. Beautiful Soup предоставляет множество различных атрибутов для
навигации и перебора дочерних тегов.</p>
<p>Обратите внимание, что строки Beautiful Soup не поддерживают ни один из этих
атрибутов, потому что строка не может иметь дочерних элементов.</p>
<div class="section" id="id20">
<h3>Навигация с использованием имен тегов<a class="headerlink" href="#id20" title="Ссылка на этот заголовок">¶</a></h3>
<p>Самый простой способ навигации по дереву разбора - это назвать имя
тега, который вам нужен. Если вы хотите получить тег &lt;head&gt;, просто скажите <code class="docutils literal notranslate"><span class="pre">soup.head</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Вы можете повторять этот трюк многократно, чтобы подробнее рассмотреть определенную часть
дерева разбора. Следующий код извлекает первый тег &lt;b&gt; внутри тега &lt;body&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;</span>
</pre></div>
</div>
<p>Использование имени тега в качестве атрибута даст вам только <cite>первый</cite> тег с таким
именем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вам нужно получить <cite>все</cite> теги &lt;a&gt; или что-нибудь более сложное,
чем первый тег с определенным именем, вам нужно будет использовать один из
методов, описанные в разделе <a href="#id62"><span class="problematic" id="id63">`Поиск дерева`_</span></a>, такие как <cite>find_all()</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="contents-children">
<h3><code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.children</span></code><a class="headerlink" href="#contents-children" title="Ссылка на этот заголовок">¶</a></h3>
<p>Дочерние теги доступны в списке под названием <code class="docutils literal notranslate"><span class="pre">.contents</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="n">head_tag</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;]</span>

<span class="n">title_tag</span> <span class="o">=</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;The Dormouse&#39;s story&#39;]</span>
</pre></div>
</div>
<p>Сам объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> имеет дочерние элементы. В этом случае
тег &lt;html&gt; является дочерним для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
<span class="c1"># 1</span>
<span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;html&#39;</span>
</pre></div>
</div>
<p>У строки нет <code class="docutils literal notranslate"><span class="pre">.contents</span></code>, потому что она не может содержать
ничего:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">text</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># AttributeError: У объекта &#39;NavigableString&#39; нет атрибута &#39;contents&#39;</span>
</pre></div>
</div>
<p>Вместо того, чтобы получать дочерние теги в виде списка, вы можете перебирать их
с помощью генератора <code class="docutils literal notranslate"><span class="pre">.children</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
</div>
<div class="section" id="descendants">
<h3><code class="docutils literal notranslate"><span class="pre">.descendants</span></code><a class="headerlink" href="#descendants" title="Ссылка на этот заголовок">¶</a></h3>
<p>Атрибуты <code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.children</span></code> применяются только в отношении
<cite>непосредственных</cite> дочерних элементов тега. Например, тег &lt;head&gt; имеет только один непосредственный
дочерний тег &lt;title&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>Но у самого тега &lt;title&gt; есть дочерний элемент: строка «The Dormouse’s
story». В некотором смысле эта строка также является дочерним элементом
тега &lt;head&gt;. Атрибут <code class="docutils literal notranslate"><span class="pre">.descendants</span></code> позволяет перебирать <cite>все</cite>
дочерние элементы тега рекурсивно: его непосредственные дочерние элементы, дочерние элементы
дочерних элементов и так далее:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
<p>У тега &lt;head&gt; есть только один дочерний элемент, но при этом у него два потомка:
тег &lt;title&gt; и его дочерний элемент. У объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
только один прямой дочерний элемент (тег &lt;html&gt;), зато множество
потомков:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
<span class="c1"># 1</span>
<span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">))</span>
<span class="c1"># 25</span>
</pre></div>
</div>
</div>
<div class="section" id="string">
<span id="id21"></span><h3><code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#string" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если у тега есть только один дочерний элемент, и это <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>,
его можно получить через <code class="docutils literal notranslate"><span class="pre">.string</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>Если единственным дочерним элементом тега является другой тег, и у этого <cite>другого</cite> тега есть строка
<code class="docutils literal notranslate"><span class="pre">.string</span></code>, то считается, что родительский тег содержит ту же строку
<code class="docutils literal notranslate"><span class="pre">.string</span></code>, что и дочерний тег:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>Если тег содержит больше чем один элемент, то становится неясным, какая из строк
<code class="docutils literal notranslate"><span class="pre">.string</span></code> относится и к родительскому тегу, поэтому <code class="docutils literal notranslate"><span class="pre">.string</span></code> родительского элемента имеет значение
<code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="strings-stripped-strings">
<span id="string-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.strings</span></code> и <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code><a class="headerlink" href="#strings-stripped-strings" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если внутри тега есть более одного элемента, вы все равно можете посмотреть только на
строки. Используйте генератор <code class="docutils literal notranslate"><span class="pre">.strings</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
<span class="c1"># u&#39;Elsie&#39;</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># u&#39;Lacie&#39;</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
</pre></div>
</div>
<p>В этих строках много лишних пробелов, которые вы можете
удалить, используя генератор <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were&#39;</span>
<span class="c1"># u&#39;Elsie&#39;</span>
<span class="c1"># u&#39;,&#39;</span>
<span class="c1"># u&#39;Lacie&#39;</span>
<span class="c1"># u&#39;and&#39;</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;...&#39;</span>
</pre></div>
</div>
<p>Так строки, состоящие исключительно из пробелов, игнорируются, а
пробелы в начале и конце строк удаляются.</p>
</div>
</div>
<div class="section" id="id22">
<h2>Проход снизу вверх<a class="headerlink" href="#id22" title="Ссылка на этот заголовок">¶</a></h2>
<p>В продолжение аналогии с «семейным деревом», каждый тег и каждая строка имеет
родителя (<cite>parent</cite>): тег, который его содержит.</p>
<div class="section" id="parent">
<span id="id23"></span><h3><code class="docutils literal notranslate"><span class="pre">.parent</span></code><a class="headerlink" href="#parent" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете получить доступ к родительскому элементу с помощью атрибута <code class="docutils literal notranslate"><span class="pre">.parent</span></code>. В
примере документа с фрагментом из «Алисы в стране чудес», тег &lt;head&gt; является родительским
для тега &lt;title&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
</pre></div>
</div>
<p>Строка заголовка сама имеет родителя: тег &lt;title&gt;, содержащий
её:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Родительским элементом тега верхнего уровня, такого как &lt;html&gt;, является сам объект
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">html</span>
<span class="nb">type</span><span class="p">(</span><span class="n">html_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.BeautifulSoup&#39;&gt;</span>
</pre></div>
</div>
<p>И <code class="docutils literal notranslate"><span class="pre">.parent</span></code> объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> определяется как None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="parents">
<span id="id24"></span><h3><code class="docutils literal notranslate"><span class="pre">.parents</span></code><a class="headerlink" href="#parents" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете перебрать всех родителей элемента с помощью
<code class="docutils literal notranslate"><span class="pre">.parents</span></code>. В следующем примере <code class="docutils literal notranslate"><span class="pre">.parents</span></code> используется для перемещения от тега &lt;a&gt;,
погребенного глубоко внутри документа, до самого верха документа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">link</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># p</span>
<span class="c1"># body</span>
<span class="c1"># html</span>
<span class="c1"># [document]</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>Перемещение вбок<a class="headerlink" href="#id25" title="Ссылка на этот заголовок">¶</a></h2>
<p>Рассмотрим простой документ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;a&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     text1</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#    &lt;c&gt;</span>
<span class="c1">#     text2</span>
<span class="c1">#    &lt;/c&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Тег &lt;b&gt; и тег &lt;c&gt; находятся на одном уровне: они оба непосредственные
дочерние элементы одного и того же тега. Мы называем их <cite>сиблингами</cite>. Когда документ
красиво отформатирован, сиблинги выводятся с одинаковым  отступом. Вы
также можете использовать это отношение в написанном вами коде.</p>
<div class="section" id="next-sibling-previous-sibling">
<h3><code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code><a class="headerlink" href="#next-sibling-previous-sibling" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> для навигации
между элементами страницы, которые находятся на одном уровне дерева разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;c&gt;text2&lt;/c&gt;</span>

<span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">previous_sibling</span>
<span class="c1"># &lt;b&gt;text1&lt;/b&gt;</span>
</pre></div>
</div>
<p>У тега &lt;b&gt; есть <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>, но нет <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>,
потому что нет ничего до тега &lt;b&gt; <cite>на том же уровне
дерева</cite>. По той же причине у тега &lt;c&gt; есть <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>,
но нет <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">previous_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Строки «text1» и «text2» <cite>не являются</cite> сиблингами, потому что они не
имеют общего родителя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;text1&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>В реальных документах <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> или <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>
тега обычно будет строкой, содержащей пробелы. Возвращаясь к
отрывку из «Алисы»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/elsie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link1&quot;</span><span class="o">&gt;</span><span class="n">Elsie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/lacie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="o">&gt;</span><span class="n">Lacie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/tillie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="o">&gt;</span><span class="n">Tillie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Вы можете подумать, что <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> первого тега &lt;a&gt;
должен быть второй тег &lt;a&gt;. Но на самом деле это строка: запятая и
перевод строки, отделяющий первый тег &lt;a&gt; от второго:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># u&#39;,\n&#39;</span>
</pre></div>
</div>
<p>Второй тег &lt;a&gt; на самом деле является <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> запятой</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-siblings-previous-siblings">
<span id="sibling-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code><a class="headerlink" href="#next-siblings-previous-siblings" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете перебрать сиблингов тега с помощью <code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> или
<code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
<span class="c1"># u&#39;; and they lived at the bottom of a well.&#39;</span>
<span class="c1"># None</span>

<span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">previous_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># &#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>Проход вперёд и назад<a class="headerlink" href="#id26" title="Ссылка на этот заголовок">¶</a></h2>
<p>Взгляните на начало отрывка из «Алисы»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;&lt;</span><span class="n">head</span><span class="o">&gt;&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>HTML-парсер берет эту строку символов и превращает ее в
серию событий: «открыть тег &lt;html&gt;», «открыть тег &lt;head&gt;», «открыть
тег &lt;html&gt;», «добавить строку», «закрыть тег &lt;title&gt;», «открыть
тег &lt;p&gt;» и так далее. Beautiful Soup предлагает инструменты для реконструирование
первоначального разбора документа.</p>
<div class="section" id="next-element-previous-element">
<span id="element-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.next_element</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_element</span></code><a class="headerlink" href="#next-element-previous-element" title="Ссылка на этот заголовок">¶</a></h3>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> строки или тега указывает на то,
что было разобрано непосредственно после него. Это могло бы быть тем же, что и
<code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>, но обычно результат резко отличается.</p>
<p>Возьмём последний тег &lt;a&gt; в документе «три сестры». Его
<code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> является строкой: конец предложения, которое было
прервано началом тега &lt;a&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_a_tag</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &#39;; and they lived at the bottom of a well.&#39;</span>
</pre></div>
</div>
<p>Но <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> этого тега &lt;a&gt; - это то, что было разобрано
сразу после тега &lt;a&gt;, <cite>не</cite> остальная часть этого предложения:
это слово «Tillie»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># u&#39;Tillie&#39;</span>
</pre></div>
</div>
<p>Это потому, что в оригинальной разметке слово «Tillie» появилось
перед точкой с запятой. Парсер обнаружил тег &lt;a&gt;, затем
слово «Tillie», затем закрывающий тег &lt;/a&gt;, затем точку с запятой и оставшуюся
часть предложения. Точка с запятой находится на том же уровне, что и тег &lt;a&gt;, но
слово «Tillie» встретилось первым.</p>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">.previous_element</span></code> является полной противоположностью
<code class="docutils literal notranslate"><span class="pre">.next_element</span></code>. Он указывает на элемент, который был встречен при разборе
непосредственно перед текущим:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-elements-previous-elements">
<h3><code class="docutils literal notranslate"><span class="pre">.next_elements</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_elements</span></code><a class="headerlink" href="#next-elements-previous-elements" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы уже должны были уловить идею. Вы можете использовать эти итераторы для перемещения
вперед или назад по документу, в том порядке, в каком он был разобран парсером:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id27">
<h1>Поиск по дереву<a class="headerlink" href="#id27" title="Ссылка на этот заголовок">¶</a></h1>
<p>Beautiful Soup определяет множество методов поиска по дереву разбора,
но они все очень похожи. Я буду долго объяснять, как работают
два самых популярных метода: <code class="docutils literal notranslate"><span class="pre">find()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>. Прочие
методы принимают практически те же самые аргументы, поэтому я просто расскажу
о них коротко.</p>
<p>И опять, я буду использовать документ «три сестры» в качестве примера:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Передав фильтр в аргумент типа <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, вы можете
углубиться в интересующие вас части документа.</p>
<div class="section" id="id28">
<h2>Виды фильтров<a class="headerlink" href="#id28" title="Ссылка на этот заголовок">¶</a></h2>
<p>Прежде чем подробно рассказывать о <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и подобных методах, я
хочу показать примеры различных фильтров, которые вы можете передать в эти
методы. Эти фильтры появляются снова и снова в
поисковом API. Вы можете использовать их для фильтрации по имени тега,
по его атрибутам, по тексту строки или по некоторой их
комбинации.</p>
<div class="section" id="a-string">
<span id="id29"></span><h3>Строка<a class="headerlink" href="#a-string" title="Ссылка на этот заголовок">¶</a></h3>
<p>Самый простой фильтр - это строка. Передайте строку в метод поиска, и
Beautiful Soup выполнит поиск соответствия этой строке. Следующий
код находит все теги &lt;b&gt; в документе:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</span>
</pre></div>
</div>
<p>Если вы передадите байтовую строку, Beautiful Soup будет считать, что строка
кодируется в UTF-8. Вы можете избежать этого, передав вместо нее строку Unicode.</p>
</div>
<div class="section" id="a-regular-expression">
<span id="id30"></span><h3>Регулярное выражение<a class="headerlink" href="#a-regular-expression" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы передадите объект с регулярным выражением, Beautiful Soup отфильтрует результаты
в соответствии с этим регулярным выражением, используя его метод <code class="docutils literal notranslate"><span class="pre">search()</span></code>. Следующий код
находит все теги, имена которых начинаются с буквы «b»; в нашем
случае это теги &lt;body&gt; и &lt;b&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^b&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># body</span>
<span class="c1"># b</span>
</pre></div>
</div>
<p>Этот код находит все теги, имена которых содержат букву „t“:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># title</span>
</pre></div>
</div>
</div>
<div class="section" id="a-list">
<span id="id31"></span><h3>Список<a class="headerlink" href="#a-list" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы передадите список, Beautiful Soup разрешит совпадение строк
с <cite>любым</cite> элементом из этого списка. Следующий код находит все теги &lt;a&gt;
<cite>и</cite> все теги &lt;b&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="true">
<span id="the-value-true"></span><h3><code class="docutils literal notranslate"><span class="pre">True</span></code><a class="headerlink" href="#true" title="Ссылка на этот заголовок">¶</a></h3>
<p>Значение <code class="docutils literal notranslate"><span class="pre">True</span></code> подходит везде, где возможно.. Следующий код находит <cite>все</cite>
теги в документе, но не текстовые строки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># head</span>
<span class="c1"># title</span>
<span class="c1"># body</span>
<span class="c1"># p</span>
<span class="c1"># b</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3>Функция<a class="headerlink" href="#id32" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если ничто из перечисленного вам не подходит, определите функцию, которая
принимает элемент в качестве единственного аргумента. Функция должна вернуть
<code class="docutils literal notranslate"><span class="pre">True</span></code>, если аргумент совпадает, и <code class="docutils literal notranslate"><span class="pre">False</span></code>, если нет.</p>
<p>Вот функция, которая возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, если в теге определён атрибут «class»,
но не определён атрибут «id»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Передайте эту функцию в <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, и вы получите все
теги &lt;p&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Эта функция выбирает только теги &lt;p&gt;. Она не выбирает теги &lt;a&gt;,
поскольку в них определены и атрибут «class» , и атрибут «id». Она не выбирает
теги вроде &lt;html&gt; и &lt;title&gt;, потому что в них не определён атрибут
«class».</p>
<p>Если вы передаете функцию для фильтрации по определенному атрибуту, такому как
<code class="docutils literal notranslate"><span class="pre">href</span></code>, аргументом, переданным в функцию, будет
значение атрибута, а не весь тег. Вот функция, которая находит все теги <code class="docutils literal notranslate"><span class="pre">a</span></code>,
у которых атрибут <code class="docutils literal notranslate"><span class="pre">href</span></code> <em>не</em> соответствует регулярному выражению:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">not_lacie</span><span class="p">(</span><span class="n">href</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">href</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;lacie&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">href</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">not_lacie</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Функция может быть настолько сложной, насколько вам нужно. Вот
функция, которая возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, если тег окружен строковыми
объектами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">NavigableString</span>
<span class="k">def</span> <span class="nf">surrounded_by_strings</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">next_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">previous_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">))</span>

<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">surrounded_by_strings</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
<p>Теперь мы готовы подробно рассмотреть методы поиска.</p>
</div>
</div>
<div class="section" id="find-all">
<h2><code class="docutils literal notranslate"><span class="pre">find_all()</span></code><a class="headerlink" href="#find-all" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_all(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#recursive"><span class="std std-ref">recursive</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> просматривает потомков тега и
извлекает <cite>всех</cite> потомков, которые соответствую вашим фильтрам. Я привел несколько
примеров в разделе <a class="reference internal" href="#id28">Виды фильтров</a>, а вот еще несколько:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;sisters&quot;</span><span class="p">))</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
</pre></div>
</div>
<p>Некоторые из них уже встречались, но другие новые. Что означает
передача значения для <code class="docutils literal notranslate"><span class="pre">string</span></code> или <code class="docutils literal notranslate"><span class="pre">id</span></code>? Почему
<code class="docutils literal notranslate"><span class="pre">find_all</span> <span class="pre">(&quot;p&quot;,</span> <span class="pre">&quot;title&quot;)</span></code> находит тег &lt;p&gt; с CSS-классом «title»?
Давайте посмотрим на аргументы <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>.</p>
<div class="section" id="name">
<span id="id33"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">name</span></code><a class="headerlink" href="#name" title="Ссылка на этот заголовок">¶</a></h3>
<p>Передайте значение для аргумента <code class="docutils literal notranslate"><span class="pre">name</span></code>, и вы скажете Beautiful Soup
рассматривать только теги с определенными именами. Текстовые строки будут игнорироваться, так же как и
теги, имена которых не соответствуют заданным.</p>
<p>Вот простейший пример использования:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>В разделе  <a class="reference internal" href="#id28">Виды фильтров</a> говорилось, что значением <code class="docutils literal notranslate"><span class="pre">name</span></code> может быть
<a class="reference internal" href="#id29">строка</a>, <a class="reference internal" href="#id30">регулярное выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или значение
<a class="reference internal" href="#true">True</a>.</p>
</div>
<div class="section" id="kwargs">
<span id="id34"></span><h3>Именованные аргументы<a class="headerlink" href="#kwargs" title="Ссылка на этот заголовок">¶</a></h3>
<p>Любой нераспознанный аргумент будет превращен в фильтр
по атрибуту тега. Если вы передаете значение для аргумента с именем <code class="docutils literal notranslate"><span class="pre">id</span></code>,
Beautiful Soup будет фильтровать по атрибуту «id» каждого тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link2&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Если вы передадите значение для <code class="docutils literal notranslate"><span class="pre">href</span></code>, Beautiful Soup отфильтрует
по атрибуту «href» каждого тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Для фильтрации по атрибуту может использоваться <a class="reference internal" href="#id29">строка</a>, <a class="reference internal" href="#id30">регулярное
выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или значение <a class="reference internal" href="#true">True</a>.</p>
<p>Следующий код находит все теги, атрибут <code class="docutils literal notranslate"><span class="pre">id</span></code> которых имеет значение,
независимо от того, что это за значение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Вы можете отфильтровать несколько атрибутов одновременно, передав более одного
именованного аргумента:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">),</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link1&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Некоторые атрибуты, такие как атрибуты data-* в HTML 5, имеют имена, которые
нельзя использовать в качестве имен именованных аргументов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#39;</span><span class="p">)</span>
<span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="c1"># SyntaxError: keyword can&#39;t be an expression</span>
</pre></div>
</div>
<p>Вы можете использовать эти атрибуты в поиске, поместив их в
словарь и передав словарь в <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> как
аргумент <code class="docutils literal notranslate"><span class="pre">attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data-foo&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span>
</pre></div>
</div>
<p>Вы не можете использовать именованный аргумент для поиска в HTML по элементу „name“,
потому что Beautiful Soup использует аргумент <code class="docutils literal notranslate"><span class="pre">name</span></code> для имени
самого тега. Вместо этого вы можете передать элемент „name“ вместе с его значением в
составе аргумента <code class="docutils literal notranslate"><span class="pre">attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;input name=&quot;email&quot;/&gt;&#39;</span><span class="p">)</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;email&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;email&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;input name=&quot;email&quot;/&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="css">
<span id="attrs"></span><h3>Поиск по классу CSS<a class="headerlink" href="#css" title="Ссылка на этот заголовок">¶</a></h3>
<p>Очень удобно искать тег с определенным классом CSS, но
имя атрибута CSS, «class», является зарезервированным словом в
Python. Использование <code class="docutils literal notranslate"><span class="pre">class</span></code> в качестве именованного аргумента приведет к синтаксической
ошибке. Начиная с Beautiful Soup 4.1.2, вы можете выполнять поиск по классу CSS, используя
именованный аргумент <code class="docutils literal notranslate"><span class="pre">class_</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Как и с любым именованным аргументом, вы можете передать в качестве значения <code class="docutils literal notranslate"><span class="pre">class_</span></code> строку, регулярное
выражение, функцию или <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;itl&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="k">def</span> <span class="nf">has_six_characters</span><span class="p">(</span><span class="n">css_class</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">css_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">css_class</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">has_six_characters</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#multivalue"><span class="std std-ref">Помните</span></a>, что один тег может иметь несколько
значений для атрибута «class». Когда вы ищете тег, который
соответствует определенному классу CSS, вы ищете соответствие <cite>любому</cite> из его
классов CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>

<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Вы также можете искать точное строковое значение атрибута <code class="docutils literal notranslate"><span class="pre">class</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Но поиск вариантов строкового значения не сработает:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout body&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Если вы хотите искать теги, которые соответствуют двум или более классам CSS, вам
следует использовать селектор CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p.strikeout.body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>В старых версиях Beautiful Soup, в которых нет ярлыка <code class="docutils literal notranslate"><span class="pre">class_</span></code>
вы можете использовать трюк  с аргументом <code class="docutils literal notranslate"><span class="pre">attrs</span></code>, упомянутый выше. Создайте
словарь, значение которого для «class» является строкой (или регулярным
выражением, или чем угодно еще), которую вы хотите найти:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="s2">&quot;sister&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<span id="id36"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">string</span></code><a class="headerlink" href="#id35" title="Ссылка на этот заголовок">¶</a></h3>
<p>С помощью <code class="docutils literal notranslate"><span class="pre">string</span></code> вы можете искать строки вместо тегов. Как и в случае с
<code class="docutils literal notranslate"><span class="pre">name</span></code> и именованными аргументами, передаваться может <a class="reference internal" href="#id29">строка</a>,
<a class="reference internal" href="#id30">регулярное выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или значения <a class="reference internal" href="#true">True</a>.
Вот несколько примеров:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Tillie&quot;</span><span class="p">,</span> <span class="s2">&quot;Elsie&quot;</span><span class="p">,</span> <span class="s2">&quot;Lacie&quot;</span><span class="p">])</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;Dormouse&quot;</span><span class="p">))</span>
<span class="p">[</span><span class="sa">u</span><span class="s2">&quot;The Dormouse&#39;s story&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;The Dormouse&#39;s story&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">is_the_only_string_within_a_tag</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if this string is the only child of its parent tag.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_the_only_string_within_a_tag</span><span class="p">)</span>
<span class="c1"># [u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;, u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;, u&#39;...&#39;]</span>
</pre></div>
</div>
<p>Хотя значение типа <code class="docutils literal notranslate"><span class="pre">string</span></code> предназначено для поиска строк, вы можете комбинировать его с
аргументами, которые находят теги: Beautiful Soup найдет все теги, в которых
<code class="docutils literal notranslate"><span class="pre">.string</span></code> соответствует вашему значению для <code class="docutils literal notranslate"><span class="pre">string</span></code>. Следующий код находит все теги &lt;a&gt;,
у которых <code class="docutils literal notranslate"><span class="pre">.string</span></code> равно «Elsie»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">string</span></code> - это новое в Beautiful Soup 4.4.0. В ранних
версиях он назывался <code class="docutils literal notranslate"><span class="pre">text</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="limit">
<span id="id37"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">limit</span></code><a class="headerlink" href="#limit" title="Ссылка на этот заголовок">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает все теги и строки, которые соответствуют вашим
фильтрам. Это может занять некоторое время, если документ большой. Если вам не
нужны <cite>все</cite> результаты, вы можете указать их предельное число - <code class="docutils literal notranslate"><span class="pre">limit</span></code>. Это
работает так же, как ключевое слово LIMIT в SQL. Оно говорит Beautiful Soup
прекратить собирать результаты после того, как их найдено определенное количество.</p>
<p>В документе «три сестры» есть три ссылки, но следующий код
находит только первые два:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="recursive">
<span id="id38"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">recursive</span></code><a class="headerlink" href="#recursive" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы вызовете <code class="docutils literal notranslate"><span class="pre">mytag.find_all()</span></code>, Beautiful Soup проверит всех
потомков <code class="docutils literal notranslate"><span class="pre">mytag</span></code>: его дочерние теги, дочерние теги дочерних тегов, и
так далее. Если вы хотите, чтобы Beautiful Soup рассматривал только непосредственных потомков (дочерние теги),
вы можете передать <code class="docutils literal notranslate"><span class="pre">recursive</span> <span class="pre">=</span> <span class="pre">False</span></code>. Оцените разницу:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Вот эта часть документа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span>
   <span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story</span>
  <span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Тег &lt;title&gt; находится под тегом &lt;html&gt;, но не <cite>непосредственно</cite>
под тегом &lt;html&gt;: на пути встречается тег &lt;head&gt;. Beautiful Soup
находит тег &lt;title&gt;, когда разрешено просматривать всех потомков
тега &lt;html&gt;, но когда <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code> ограничивает поиск
только непосредстввенно дочерними тегами,  Beautiful Soup ничего не находит.</p>
<p>Beautiful Soup предлагает множество методов поиска по дереву (они рассмотрены ниже),
и они в основном принимают те же аргументы, что и <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>: <code class="docutils literal notranslate"><span class="pre">name</span></code>,
<code class="docutils literal notranslate"><span class="pre">attrs</span></code>, <code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">limit</span></code>, и именованные аргументы. Но
с аргументом <code class="docutils literal notranslate"><span class="pre">recursive</span></code> все иначе:  <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и <code class="docutils literal notranslate"><span class="pre">find()</span></code> -
это единственные методы, которые его поддерживают. От передачи <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code> в
метод типа <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> не очень много пользы.</p>
</div>
</div>
<div class="section" id="id39">
<h2>Вызов тега похож на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code><a class="headerlink" href="#id39" title="Ссылка на этот заголовок">¶</a></h2>
<p>Поскольку <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> является самым популярным методом в Beautiful
Soup API, вы можете использовать сокращенную запись. Если относиться к
объекту  <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или объекту <code class="docutils literal notranslate"><span class="pre">Tag</span></code> так, будто это
функция, то это похоже на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>
﻿с этим объектом. Эти две строки кода эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Эти две строки также эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="find">
<h2><code class="docutils literal notranslate"><span class="pre">find()</span></code><a class="headerlink" href="#find" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#recursive"><span class="std std-ref">recursive</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> сканирует весь документ в поиске
всех результатов, но иногда вам нужен только один. Если вы знаете,
что в документе есть только один тег &lt;body&gt;, нет смысла сканировать
весь документ в поиске остальных. Вместо того, чтобы передавать <code class="docutils literal notranslate"><span class="pre">limit=1</span></code>
каждый раз, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, используйте
метод <code class="docutils literal notranslate"><span class="pre">find()</span></code>. Эти две строки кода эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Разница лишь в том, что <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает список, содержащий
единственный результат, а <code class="docutils literal notranslate"><span class="pre">find()</span></code> возвращает только сам результат.</p>
<p>Если <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> не может ничего найти, он возвращает пустой список. Если
<code class="docutils literal notranslate"><span class="pre">find()</span></code> не может ничего найти, он возвращает <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;nosuchtag&quot;</span><span class="p">))</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Помните трюк с <code class="docutils literal notranslate"><span class="pre">soup.head.title</span></code> из раздела
<a class="reference internal" href="#id20">Навигация с использованием имен тегов</a>? Этот трюк работает на основе неоднократного вызова <code class="docutils literal notranslate"><span class="pre">find()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;head&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-parents-find-parent">
<h2><code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code><a class="headerlink" href="#find-parents-find-parent" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_parents(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_parent(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Я долго объяснял, как работают <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и
<code class="docutils literal notranslate"><span class="pre">find()</span></code>. Beautiful Soup API определяет десяток других методов для
поиска по дереву, но пусть вас это не пугает. Пять из этих методов
в целом похожи на <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, а другие пять в целом
похожи на <code class="docutils literal notranslate"><span class="pre">find()</span></code>. Единственное различия в том, по каким частям
дерева они ищут.</p>
<p>Сначала давайте рассмотрим <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и
<code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>. Помните, что <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и <code class="docutils literal notranslate"><span class="pre">find()</span></code> прорабатывают
дерево сверху вниз, просматривая теги и их потомков. <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>
делают наоборот: они идут <cite>снизу вверх</cite>, рассматривая
родительские элементы тега или строки. Давайте испытаем их, начав со строки,
погребенной глубоко в документе «три сестры»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_string</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Lacie&quot;</span><span class="p">)</span>
<span class="n">a_string</span>
<span class="c1"># u&#39;Lacie&#39;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="c1">#  and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Один из трех тегов &lt;a&gt; является прямым родителем искомой строки,
так что наш поиск находит его. Один из трех тегов &lt;p&gt; является
непрямым родителем строки, и наш поиск тоже его
находит. Где-то в документе есть тег &lt;p&gt; с классом CSS «title»,
но он не является родительским для строки, так что мы не можем найти
его с помощью <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code>.</p>
<p>Вы могли заметить связь между <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>,
<code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и атрибутами <a class="reference internal" href="#parent">.parent</a> и <a class="reference internal" href="#parents">.parents</a>,
упомянутыми ранее. Связь очень сильная. Эти методы поиска
на самом деле используют <code class="docutils literal notranslate"><span class="pre">.parents</span></code>, чтобы перебрать все родительские элементы и проверить
каждый из них на соответствие заданному фильтру.</p>
</div>
<div class="section" id="find-next-siblings-find-next-sibling">
<h2><code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code><a class="headerlink" href="#find-next-siblings-find-next-sibling" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_next_siblings(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_next_sibling(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#sibling-generators"><span class="std std-ref">.next_siblings</span></a> для
перебора остальных сиблингов элемента в дереве. Метод
<code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> возвращает всех  подходящих сиблингов,
а <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code> возвращает только первый из них:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_next_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-previous-siblings-find-previous-sibling">
<h2><code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous_sibling()</span></code><a class="headerlink" href="#find-previous-siblings-find-previous-sibling" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_previous_siblings(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_previous_sibling(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#sibling-generators"><span class="std std-ref">.previous_siblings</span></a> для перебора тех сиблингов элемента,
которые предшествуют ему в дереве разбора. Метод <code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code>
возвращает всех подходящих сиблингов, а
а <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code> только первого из них:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_link</span><span class="o">.</span><span class="n">find_previous_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_previous_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-all-next-find-next">
<h2><code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next()</span></code><a class="headerlink" href="#find-all-next-find-next" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_all_next(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_next(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#element-generators"><span class="std std-ref">.next_elements</span></a> для
перебора любых тегов и строк, которые встречаются в документе после
элемента. Метод <code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> возвращает все совпадения, а
<code class="docutils literal notranslate"><span class="pre">find_next()</span></code> только первое:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_next</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c1">#  u&#39;;\nand they lived at the bottom of a well.&#39;, u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
<p>В первом примере нашлась строка «Elsie», хотя она
содержится в теге &lt;a&gt;, с которого мы начали. Во втором примере
нашелся последний тег &lt;p&gt;, хотя он находится
в другой части дерева, чем тег &lt;a&gt;, с которого мы начали. Для этих
методов имеет значение только то, что элемент соответствует фильтру и
появляется в документе позже, чем тот элемент, с которого начали поиск.</p>
</div>
<div class="section" id="find-all-previous-find-previous">
<h2><code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous()</span></code><a class="headerlink" href="#find-all-previous-find-previous" title="Ссылка на этот заголовок">¶</a></h2>
<p>Сигнатура: find_all_previous(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_previous(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#element-generators"><span class="std std-ref">.previous_elements</span></a> для
перебора любых тегов и строк, которые встречаются в документе до
элемента. Метод <code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> возвращает все совпадения, а
<code class="docutils literal notranslate"><span class="pre">find_previous()</span></code> только первое:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_previous</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_previous</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Вызов <code class="docutils literal notranslate"><span class="pre">find_all_previous</span> <span class="pre">(&quot;p&quot;)</span></code> нашел первый абзац в
документе (тот, который с class = «title»), но он также находит
второй абзац, тег &lt;p&gt;, содержащий тег &lt;a&gt;, с которого мы
начали. Это не так уж удивительно: мы смотрим на все теги,
которые появляются в документе раньше, чем тот, с которого мы начали. Тег
&lt;p&gt;, содержащий тег &lt;a&gt;, должен был появиться до тега &lt;a&gt;, который
в нем содержится.</p>
</div>
<div class="section" id="id40">
<h2>Селекторы CSS<a class="headerlink" href="#id40" title="Ссылка на этот заголовок">¶</a></h2>
<p>Начиная с версии 4.7.0, Beautiful Soup поддерживает большинство селекторов CSS4 благодаря
проекту <a class="reference external" href="https://facelessuser.github.io/soupsieve/">SoupSieve</a>. Если вы установили Beautiful Soup через <code class="docutils literal notranslate"><span class="pre">pip</span></code>, SoupSieve
был установлен одновременно с ним, так что вам не нужно делать ничего дополнительно.</p>
<p>В <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> есть метод <code class="docutils literal notranslate"><span class="pre">.select()</span></code>, который использует SoupSieve, чтобы
запустить селектор CSS и вернуть все
подходящие элементы. <code class="docutils literal notranslate"><span class="pre">Tag</span></code> имеет похожий метод, который запускает селектор CSS
в отношении содержимого одного тега.</p>
<p>(В более ранних версиях Beautiful Soup тоже есть метод <code class="docutils literal notranslate"><span class="pre">.select()</span></code>,
но поддерживаются только наиболее часто используемые селекторы CSS.)</p>
<p>В <a class="reference external" href="https://facelessuser.github.io/soupsieve/">документации SoupSieve</a> перечислены все
селекторы CSS, которые поддерживаются на данный момент, но вот некоторые из основных:</p>
<p>Вы можете найти теги:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p:nth-of-type(3)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Найти теги под другими тегами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;html head title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>Найти теги <cite>непосредственно</cite> под другими тегами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;head &gt; title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a:nth-of-type(2)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; #link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Найти сиблингов тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 ~ .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot;  id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 + .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по классу CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;[class~=sister]&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по ID:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;a#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги, которые соответствуют любому селектору из списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1,#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Проверка на наличие атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по значению атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href=&quot;http://example.com/elsie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href^=&quot;http://example.com/&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href$=&quot;tillie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href*=&quot;.com/el&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Есть также метод <code class="docutils literal notranslate"><span class="pre">select_one()</span></code>, который находит только
первый тег, соответствующий селектору:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вы разобрали XML, в котором определено пространства имен, вы можете использовать их в
селекторах CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">xml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;tag xmlns:ns1=&quot;http://namespace1/&quot; xmlns:ns2=&quot;http://namespace2/&quot;&gt;</span>
<span class="s2"> &lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;</span>
<span class="s2"> &lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;</span>
<span class="s2">&lt;/tag&gt; &quot;&quot;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;, &lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;ns1|child&quot;</span><span class="p">,</span> <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
<p>При обработке селектора CSS, который использует пространства имен, Beautiful Soup
использует сокращения пространства имен, найденные при разборе
документа. Вы можете заменить сокращения своими собственными, передав словарь
сокращений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="s2">&quot;http://namespace1/&quot;</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s2">&quot;http://namespace2/&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;second|child&quot;</span><span class="p">,</span> <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 2&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
<p>Все эти селекторы CSS удобны для тех, кто уже
знаком с синтаксисом селекторов CSS. Вы можете сделать все это с помощью
Beautiful Soup API. И если CSS селекторы - это все, что вам нужно, вам следует
использовать парсер lxml: это намного быстрее. Но вы можете
<cite>комбинировать</cite> селекторы CSS с Beautiful Soup API.</p>
</div>
</div>
<div class="section" id="id42">
<h1>Изменение дерева<a class="headerlink" href="#id42" title="Ссылка на этот заголовок">¶</a></h1>
<p>Основная сила Beautiful Soup в поиске по дереву разбора, но вы
также можете изменить дерево и записать свои изменения в виде нового HTML- или XML-
документа.</p>
<div class="section" id="id43">
<h2>Изменение имен тегов и атрибутов<a class="headerlink" href="#id43" title="Ссылка на этот заголовок">¶</a></h2>
<p>Я говорил об этом раньше, в разделе <a class="reference internal" href="#id15">Атрибуты</a>, но это стоит повторить. Вы
можете переименовать тег, изменить значения его атрибутов, добавить новые
атрибуты и удалить атрибуты:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>Изменение <code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#id44" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы замените значение атрибута <code class="docutils literal notranslate"><span class="pre">.string</span></code> новой строкой, содержимое тега будет
заменено на эту строку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>

<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;New link text.&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;New link text.&lt;/a&gt;</span>
</pre></div>
</div>
<p>Будьте осторожны: если тег содержит другие теги, они и все их
содержимое будет уничтожено.</p>
</div>
<div class="section" id="append">
<h2><code class="docutils literal notranslate"><span class="pre">append()</span></code><a class="headerlink" href="#append" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вы можете добавить содержимое тега с помощью <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code>. Это работает
точно так же, как <code class="docutils literal notranslate"><span class="pre">.append()</span></code> для списка в Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Foo&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>

<span class="n">soup</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Foo&#39;, u&#39;Bar&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="extend">
<h2><code class="docutils literal notranslate"><span class="pre">extend()</span></code><a class="headerlink" href="#extend" title="Ссылка на этот заголовок">¶</a></h2>
<p>Начиная с версии Beautiful Soup 4.7.0, <code class="docutils literal notranslate"><span class="pre">Tag</span></code> также поддерживает метод
<code class="docutils literal notranslate"><span class="pre">.extend()</span></code>, который работает так же, как вызов <code class="docutils literal notranslate"><span class="pre">.extend()</span></code> для
списка в Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Soup&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;&#39;s&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">])</span>

<span class="n">soup</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;Soup&#39;s on&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Soup&#39;, u&#39;&#39;s&#39;, u&#39; &#39;, u&#39;on&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="navigablestring-new-tag">
<h2><code class="docutils literal notranslate"><span class="pre">NavigableString()</span></code> и <code class="docutils literal notranslate"><span class="pre">.new_tag()</span></code><a class="headerlink" href="#navigablestring-new-tag" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вам нужно добавить строку в документ, нет проблем - вы можете передать
строку Python в <code class="docutils literal notranslate"><span class="pre">append()</span></code> или вызвать
конструктор <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="n">new_string</span> <span class="o">=</span> <span class="n">NavigableString</span><span class="p">(</span><span class="s2">&quot; there&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_string</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there.&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Hello&#39;, u&#39; there&#39;]</span>
</pre></div>
</div>
<p>Если вы хотите создать комментарий или другой подкласс
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, просто вызовите конструктор:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">Comment</span>
<span class="n">new_comment</span> <span class="o">=</span> <span class="n">Comment</span><span class="p">(</span><span class="s2">&quot;Nice to see you.&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comment</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Hello&#39;, u&#39; there&#39;, u&#39;Nice to see you.&#39;]</span>
</pre></div>
</div>
<p>(Это новая функция в Beautiful Soup 4.4.0.)</p>
<p>Что делать, если вам нужно создать совершенно новый тег?  Наилучшим решением будет
вызвать фабричный метод <code class="docutils literal notranslate"><span class="pre">BeautifulSoup.new_tag()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">original_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://www.example.com&quot;</span><span class="p">)</span>
<span class="n">original_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;&lt;/a&gt;&lt;/b&gt;</span>

<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Link text.&quot;</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span>
</pre></div>
</div>
<p>Нужен только первый аргумент, имя тега.</p>
</div>
<div class="section" id="insert">
<h2><code class="docutils literal notranslate"><span class="pre">insert()</span></code><a class="headerlink" href="#insert" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.insert()</span></code> похож на <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code>, за исключением того, что новый элемент
не обязательно добавляется в конец родительского
<code class="docutils literal notranslate"><span class="pre">.contents</span></code>. Он добавится в любое место, номер которого
вы укажете. Это работает в точности как <code class="docutils literal notranslate"><span class="pre">.insert()</span></code> в списке Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;but did not endorse &quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;I linked to &#39;, u&#39;but did not endorse&#39;, &lt;i&gt;example.com&lt;/i&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="insert-before-insert-after">
<h2><code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> и <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code><a class="headerlink" href="#insert-before-insert-after" title="Ссылка на этот заголовок">¶</a></h2>
<p>Метод <code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> вставляет теги или строки непосредственно
перед чем-то в дереве разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;stop&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Don&#39;t&quot;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">insert_before</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt;stop&lt;/b&gt;</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code> вставляет теги или строки непосредственно
после чего-то в дереве разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">div</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
<span class="n">div</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;ever&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">insert_after</span><span class="p">(</span><span class="s2">&quot; you &quot;</span><span class="p">,</span> <span class="n">div</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt; you &lt;div&gt;ever&lt;/div&gt; stop&lt;/b&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;i&gt;Don&#39;t&lt;/i&gt;, u&#39; you&#39;, &lt;div&gt;ever&lt;/div&gt;, u&#39;stop&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="clear">
<h2><code class="docutils literal notranslate"><span class="pre">clear()</span></code><a class="headerlink" href="#clear" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.clear()</span></code> удаляет содержимое тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="extract">
<h2><code class="docutils literal notranslate"><span class="pre">extract()</span></code><a class="headerlink" href="#extract" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.extract()</span></code> удаляет тег или строку из дерева. Он
возвращает тег или строку, которая была извлечена и удалена:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>

<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;example.com&lt;/i&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">i_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="kc">None</span>
</pre></div>
</div>
<p>К этому моменту у вас фактически есть два дерева разбора: одно в
объекте <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, который вы использовали, чтобы разобрать документ, другое в
теге, который был извлечен. Вы можете далее вызывать <code class="docutils literal notranslate"><span class="pre">extract</span></code> в отношении
дочернего элемента того тега, который был извлечен:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_string</span> <span class="o">=</span> <span class="n">i_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
<span class="n">my_string</span>
<span class="c1"># u&#39;example.com&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">my_string</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;&lt;/i&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="decompose">
<h2><code class="docutils literal notranslate"><span class="pre">decompose()</span></code><a class="headerlink" href="#decompose" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.decompose()</span></code> удаляет тег из дерева, а затем <cite>полностью
уничтожает его вместе с его содержимым</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="replace-with">
<span id="id45"></span><h2><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code><a class="headerlink" href="#replace-with" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.extract()</span></code> удаляет тег или строку из дерева
и заменяет его тегом или строкой по вашему выбору:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;example.net&quot;</span>
<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code> возвращает тег или строку, которые были заменены, так что
вы можете изучить его или добавить его обратно в другую часть дерева.</p>
</div>
<div class="section" id="wrap">
<h2><code class="docutils literal notranslate"><span class="pre">wrap()</span></code><a class="headerlink" href="#wrap" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.wrap()</span></code> обертывает элемент в указанный вами тег. Он
возвращает новую обертку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;I wish I was bold.&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="c1"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">)</span>
<span class="c1"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span>
</pre></div>
</div>
<p>Это новый метод в Beautiful Soup 4.0.5.</p>
</div>
<div class="section" id="unwrap">
<h2><code class="docutils literal notranslate"><span class="pre">unwrap()</span></code><a class="headerlink" href="#unwrap" title="Ссылка на этот заголовок">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.unwrap()</span></code> - это противоположность <code class="docutils literal notranslate"><span class="pre">wrap()</span></code>. Он заменяет весь тег на
его содержимое. Этим методом удобно очищать разметку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to example.com&lt;/a&gt;</span>
</pre></div>
</div>
<p>Как и <code class="docutils literal notranslate"><span class="pre">replace_with()</span></code>, <code class="docutils literal notranslate"><span class="pre">unwrap()</span></code> возвращает тег,
который был заменен.</p>
</div>
<div class="section" id="smooth">
<h2><code class="docutils literal notranslate"><span class="pre">smooth()</span></code><a class="headerlink" href="#smooth" title="Ссылка на этот заголовок">¶</a></h2>
<p>После вызова ряда методов, которые изменяют дерево разбора, у вас может оказаться несколько объектов <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> подряд. У Beautiful Soup с этим нет проблем, но поскольку такое не случается со свежеразобранным документом, вам может показаться неожиданным следующее поведение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;A one&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, a two&quot;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;A one&#39;, u&#39;, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;A one, a two&lt;/p&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one</span>
<span class="c1">#  , a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>Вы можете вызвать <code class="docutils literal notranslate"><span class="pre">Tag.smooth()</span></code>, чтобы очистить дерево разбора путем объединения смежных строк:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;A one, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one, a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth()</span></code> - это новый метод в Beautiful Soup 4.8.0.</p>
</div>
</div>
<div class="section" id="id46">
<h1>Вывод<a class="headerlink" href="#id46" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="prettyprinting">
<span id="id47"></span><h2>Красивое форматирование<a class="headerlink" href="#prettyprinting" title="Ссылка на этот заголовок">¶</a></h2>
<p>Метод <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> превратит дерево разбора Beautiful Soup в
красиво отформатированную строку Unicode, где каждый
тег и каждая строка выводятся на отдельной строчке:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">()</span>
<span class="c1"># &#39;&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href=&quot;http://example.com/&quot;&gt;\n...&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#    I linked to</span>
<span class="c1">#    &lt;i&gt;</span>
<span class="c1">#     example.com</span>
<span class="c1">#    &lt;/i&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Вы можете вызвать <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> верхнего уровня
или для любого из его объектов <code class="docutils literal notranslate"><span class="pre">Tag</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#  I linked to</span>
<span class="c1">#  &lt;i&gt;</span>
<span class="c1">#   example.com</span>
<span class="c1">#  &lt;/i&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>Без красивого форматирования<a class="headerlink" href="#id48" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вам нужна просто строка, без особого форматирования, вы можете вызвать
<code class="docutils literal notranslate"><span class="pre">unicode()</span></code> или <code class="docutils literal notranslate"><span class="pre">str()</span></code> для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или объекта <code class="docutils literal notranslate"><span class="pre">Tag</span></code>
внутри:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="n">unicode</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># u&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
</pre></div>
</div>
<p>Функция <code class="docutils literal notranslate"><span class="pre">str()</span></code> возвращает строку, кодированную в UTF-8. Для получения более подробной информации см.
<a class="reference internal" href="#id52">Кодировки</a>.</p>
<p>Вы также можете вызвать <code class="docutils literal notranslate"><span class="pre">encode()</span></code> для получения байтовой строки, и <code class="docutils literal notranslate"><span class="pre">decode()</span></code>,
чтобы получить Unicode.</p>
</div>
<div class="section" id="output-formatters">
<span id="id49"></span><h2>Средства форматирования вывода<a class="headerlink" href="#output-formatters" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы дадите Beautiful Soup документ, который содержит HTML-сущности, такие как
«&amp;lquot;», они будут преобразованы в символы Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;</span><span class="p">)</span>
<span class="n">unicode</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># u&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
<p>Если затем преобразовать документ в строку, символы Unicode
будет кодироваться как UTF-8. Вы не получите обратно HTML-сущности:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
<p>По умолчанию единственные символы, которые экранируются при выводе - это чистые
амперсанды и угловые скобки. Они превращаются в «&amp;», «&lt;»
и «&gt;», чтобы Beautiful Soup случайно не сгенерировал
невалидный HTML или XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;The law firm of Dewey, Cheatem, &amp; Howe&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p&gt;The law firm of Dewey, Cheatem, &amp;amp; Howe&lt;/p&gt;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;amp;bar=val2&quot;&gt;A link&lt;/a&gt;</span>
</pre></div>
</div>
<p>Вы можете изменить это поведение, указав для
аргумента <code class="docutils literal notranslate"><span class="pre">formatter</span></code> одно из значений: <code class="docutils literal notranslate"><span class="pre">prettify()</span></code>, <code class="docutils literal notranslate"><span class="pre">encode()</span></code> или
<code class="docutils literal notranslate"><span class="pre">decode()</span></code>. Beautiful Soup распознает пять возможных значений
<code class="docutils literal notranslate"><span class="pre">formatter</span></code>.</p>
<p>Значение по умолчанию - <code class="docutils literal notranslate"><span class="pre">formatter=&quot;minimal&quot;</span></code>. Строки будут обрабатываться
ровно настолько, чтобы Beautiful Soup генерировал валидный HTML / XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">french</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">french</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;minimal&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &amp;lt;&amp;lt;Sacré bleu!&amp;gt;&amp;gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передадите <code class="docutils literal notranslate"><span class="pre">formatter</span> <span class="pre">=</span> <span class="pre">&quot;html&quot;</span></code>, Beautiful Soup преобразует
символы Unicode в HTML-сущности, когда это возможно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передаете <code class="docutils literal notranslate"><span class="pre">formatter=&quot;html5&quot;</span></code>, это то же самое, что
<code class="docutils literal notranslate"><span class="pre">formatter=&quot;html&quot;</span></code>, только Beautiful Soup будет
пропускать закрывающую косую черту в пустых тегах HTML, таких как «br»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html5&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передадите <code class="docutils literal notranslate"><span class="pre">formatter=None</span></code>, Beautiful Soup вообще не будет менять
строки на выходе. Это самый быстрый вариант, но он может привести
к тому, что Beautiful Soup будет генерировать невалидный HTML / XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &lt;&lt;Sacré bleu!&gt;&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>

<span class="n">link_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вам нужен более сложный контроль над выводом, вы можете
использовать класс <code class="docutils literal notranslate"><span class="pre">Formatter</span></code> из Beautiful Soup. Вот средство форматирования, которое
преобразует строки в верхний регистр, независимо от того, находятся ли они в текстовом узле или в
значении атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.formatter</span> <span class="kn">import</span> <span class="n">HTMLFormatter</span>
<span class="k">def</span> <span class="nf">uppercase</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">HTMLFormatter</span><span class="p">(</span><span class="n">uppercase</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    IL A DIT &lt;&lt;SACRÉ BLEU!&gt;&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;HTTP://EXAMPLE.COM/?FOO=VAL1&amp;BAR=VAL2&quot;&gt;</span>
<span class="c1">#  A LINK</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
<p>Подклассы <code class="docutils literal notranslate"><span class="pre">HTMLFormatter</span></code> или <code class="docutils literal notranslate"><span class="pre">XMLFormatter</span></code> дают еще
больший контроль над выводом. Например, Beautiful Soup сортирует
атрибуты в каждом теге по умолчанию:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">attr_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&lt;p z=&quot;1&quot; m=&quot;2&quot; a=&quot;3&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># &lt;p a=&quot;3&quot; m=&quot;2&quot; z=&quot;1&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Чтобы выключить сортировку по умолчанию, вы можете создать подкласс  на основе метода <code class="docutils literal notranslate"><span class="pre">Formatter.attributes()</span></code>,
который контролирует, какие атрибуты выводятся и в каком
порядке. Эта реализация также отфильтровывает атрибут с именем «m»,
где бы он ни появился:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UnsortedAttributes</span><span class="p">(</span><span class="n">HTMLFormatter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">UnsortedAttributes</span><span class="p">()))</span>
<span class="c1"># &lt;p z=&quot;1&quot; a=&quot;3&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Последнее предостережение: если вы создаете объект <code class="docutils literal notranslate"><span class="pre">CData</span></code>, текст внутри
этого объекта всегда представлен <cite>как есть, без какого-либо
форматирования</cite>. Beautiful Soup вызовет вашу функцию для замены сущностей,
на тот случай, если вы написали функцию, которая подсчитывает
все строки в документе или что-то еще, но он будет игнорировать
возвращаемое значение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.element</span> <span class="kn">import</span> <span class="n">CData</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">&quot;one &lt; three&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">))</span>
<span class="c1"># &lt;a&gt;</span>
<span class="c1">#  &lt;![CDATA[one &lt; three]]&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="get-text">
<h2><code class="docutils literal notranslate"><span class="pre">get_text()</span></code><a class="headerlink" href="#get-text" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вам нужна только текстовая часть документа или тега, вы можете использовать
метод <code class="docutils literal notranslate"><span class="pre">get_text()</span></code>. Он возвращает весь текст документа или
тега в виде единственной строки Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;</span><span class="se">\n</span><span class="s1">I linked to &lt;i&gt;example.com&lt;/i&gt;</span><span class="se">\n</span><span class="s1">&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="sa">u</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">I linked to example.com</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="sa">u</span><span class="s1">&#39;example.com&#39;</span>
</pre></div>
</div>
<p>Вы можете указать строку, которая будет использоваться для объединения текстовых фрагментов
в единую строку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># soup.get_text(&quot;|&quot;)</span>
<span class="sa">u</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">I linked to |example.com|</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>Вы можете сказать Beautiful Soup удалять пробелы в начале и
конце каждого текстового фрагмента:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># soup.get_text(&quot;|&quot;, strip=True)</span>
<span class="sa">u</span><span class="s1">&#39;I linked to|example.com&#39;</span>
</pre></div>
</div>
<p>Но в этом случае вы можете предпочесть использовать генератор <a class="reference internal" href="#string-generators"><span class="std std-ref">.stripped_strings</span></a>
и затем обработать текст самостоятельно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">text</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">]</span>
<span class="c1"># [u&#39;I linked to&#39;, u&#39;example.com&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id50">
<h1>Указание парсера<a class="headerlink" href="#id50" title="Ссылка на этот заголовок">¶</a></h1>
<p>Если вам нужно просто разобрать HTML, вы можете скинуть разметку в
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, и, скорее всего, все будет в порядке. Beautiful
Soup подберет для вас парсер и проанализирует данные. Но есть
несколько дополнительных аргументов, которые вы можете передать конструктору, чтобы изменить
используемый парсер.</p>
<p>Первым аргументом конструктора <code class="docutils literal notranslate"><span class="pre">BeautifulSou</span></code> является строка или
открытый дескриптор файла - сама разметка, которую вы хотите разобрать. Второй аргумент - это
<cite>как</cite> вы хотите, чтобы разметка была разобрана.</p>
<p>Если вы ничего не укажете, будет использвоаться лучший HTML-парсер из тех,
которые установлены. Beautiful Soup оценивает парсер lxml как лучший, за ним идет
html5lib, затем встроенный парсер Python. Вы можете переопределить используемый парсер,
указав что-то из следующего:</p>
<ul class="simple">
<li><p>Какой тип разметки вы хотите разобрать. В данный момент поддерживаются:
«html», «xml» и «html5».</p></li>
<li><p>Имя библиотеки парсера, которую вы хотите использовать. В данный момент поддерживаются:
варианты «lxml», «html5lib» и «html.parser» (встроенный в Python
парсер HTML).</p></li>
</ul>
<p>В разделе <a class="reference internal" href="#id10">Установка парсера</a> сравниваются поддерживаемые парсеры.</p>
<p>Если у вас не установлен соответствующий парсер, Beautiful Soup
проигнорирует ваш запрос и выберет другой парсер. На текущий момент единственный
поддерживаемый парсер XML - это lxml. Если у вас не установлен lxml, запрос на
парсер XML ничего не даст, и запрос «lxml» тоже
не сработает.</p>
<div class="section" id="id51">
<h2>Различия между парсерами<a class="headerlink" href="#id51" title="Ссылка на этот заголовок">¶</a></h2>
<p>Beautiful Soup представляет один интерфейс для разных
парсеров, но парсеры неодинаковы. Разные парсеры создадут
различные деревья разбора из одного и того же документа. Самые большие различия будут
между парсерами HTML и парсерами XML. Вот короткий
документ, разобранный как HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Поскольку пустой тег &lt;b /&gt; не является валидным кодом HTML, парсер превращает его в
пару тегов &lt;b&gt;&lt;/b&gt;.</p>
<p>Вот тот же документ, который разобран как XML (для его запуска нужно, чтобы был
установлен lxml). Обратите внимание, что пустой тег &lt;b /&gt; остается, и
что в документ добавляется объявление XML вместо
тега &lt;html&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="c1"># &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="c1"># &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>Есть также различия между парсерами HTML. Если вы даете Beautiful
Soup идеально оформленный документ HTML, эти различия не будут
иметь значения. Один парсер будет быстрее другого, но все они будут давать
структуру данных, которая выглядит точно так же, как оригинальный
документ HTML.</p>
<p>Но если документ оформлен неидеально, различные парсеры
дадут разные результаты. Вот короткий невалидный документ, разобранный с помощью
HTML-парсера lxml. Обратите внимание, что висячий тег &lt;/p&gt; просто
игнорируется:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Вот тот же документ, разобранный с помощью html5lib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html5lib&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Вместо того, чтобы игнорировать висячий тег &lt;/p&gt;, html5lib добавляет
открывающй тег &lt;p&gt;. Этот парсер также добавляет пустой тег &lt;head&gt; в
документ.</p>
<p>Вот тот же документ, разобранный с помощью встроенного в Python
парсера HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>Как и html5lib, этот парсер игнорирует закрывающий тег &lt;/p&gt;. В отличие от
html5lib, этот парсер не делает попытки создать правильно оформленный HTML-
документ, добавив тег &lt;body&gt;. В отличие от lxml, он даже не
добавляет тег &lt;html&gt;.</p>
<p>Поскольку документ «&lt;a&gt;&lt;/p&gt;» невалиден, ни один из этих способов
нельзя назвать «правильным». Парсер html5lib использует способы,
которые являются частью стандарта HTML5, поэтому он может претендовать на то, что его подход
самый «правильный», но правомерно использовать любой из трех методов.</p>
<p>Различия между парсерами могут повлиять на ваш скрипт. Если вы планируете
распространять ваш скрипт или запускать его на нескольких
машинах, вам нужно указать парсер в
конструкторе <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Это уменьшит вероятность того, что ваши пользователи при разборе
документа получат результат, отличный от вашего.</p>
</div>
</div>
<div class="section" id="id52">
<h1>Кодировки<a class="headerlink" href="#id52" title="Ссылка на этот заголовок">¶</a></h1>
<p>Любой документ HTML или XML написан в определенной кодировке, такой как ASCII
или UTF-8.  Но когда вы загрузите этот документ в Beautiful Soup, вы
обнаружите, что он был преобразован в Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;h1&gt;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="c1"># &lt;h1&gt;Sacré bleu!&lt;/h1&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;Sacr\xe9 bleu!&#39;</span>
</pre></div>
</div>
<p>Это не волшебство. (Хотя это было бы здорово, конечно). Beautiful Soup использует
подбиблиотеку под названием <a class="reference internal" href="#unicode-dammit">Unicode, Dammit</a> для определения кодировки документа
и преобразования ее в Unicode. Кодировка, которая была автоматически определена, содержится в значении
атрибута <code class="docutils literal notranslate"><span class="pre">.original_encoding</span></code> объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;utf-8&#39;</span>
</pre></div>
</div>
<p>Unicode, Dammit чаще всего угадывает правильно, но иногда
делает ошибки. Иногда он угадывает правильно только после
побайтового поиска по документу, что занимает очень много времени. Если
вы вдруг уже знаете кодировку документа, вы можете избежать
ошибок и задержек, передав кодировку конструктору <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
как аргумент `` from_encoding``.</p>
<p>Вот документ, написанный на ISO-8859-8. Документ настолько короткий, что
Unicode, Dammit не может разобраться и неправильно идентифицирует кодировку как
ISO-8859-7:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&lt;h1&gt;</span><span class="se">\xed\xe5\xec\xf9</span><span class="s2">&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">νεμω</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;ISO-8859-7&#39;</span>
</pre></div>
</div>
<p>Мы можем все исправить, передав правильный <code class="docutils literal notranslate"><span class="pre">from_encoding</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="n">from_encoding</span><span class="o">=</span><span class="s2">&quot;iso-8859-8&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">םולש</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;iso8859-8&#39;</span>
</pre></div>
</div>
<p>Если вы не знаете правильную кодировку, но вы видите, что
Unicode, Dammit определяет кодировку неправильно, вы можете передать ошибочные варианты в
<code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="n">exclude_encodings</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ISO-8859-7&quot;</span><span class="p">])</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">םולש</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;WINDOWS-1255&#39;</span>
</pre></div>
</div>
<p>Windows-1255 не на 100% подходит, но это совместимое
надмножество ISO-8859-8, так что догадка почти верна. (<code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code>
- это новая функция в Beautiful Soup 4.4.0.)</p>
<p>В редких случаях (обычно, когда документ UTF-8 содержит текст в
совершенно другая кодировка), единственным способом получить Unicode может оказаться
замена некоторых символов специальным символом Unicode
«REPLACEMENT CHARACTER» (U+FFFD, �). Если Unicode, Dammit приходится это сделать,
он установит атрибут <code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code>
в <code class="docutils literal notranslate"><span class="pre">True</span></code> на объекте <code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code> или <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Это
даст понять, что представление в виде Unicode не является точным
представление оригинала, и что некоторые данные потерялись. Если документ
содержит �, но <code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code> равен <code class="docutils literal notranslate"><span class="pre">False</span></code>,
вы будете знать, что � был в тексте изначально (как в этом
параграфе), а не служит заменой отсутствующим данным.</p>
<div class="section" id="output-encoding">
<h2>Output encoding<a class="headerlink" href="#output-encoding" title="Ссылка на этот заголовок">¶</a></h2>
<p>When you write out a document from Beautiful Soup, you get a UTF-8
document, even if the document wasn’t in UTF-8 to begin with. Here’s a
document written in the Latin-1 encoding:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1"> &lt;html&gt;</span>
<span class="s1">  &lt;head&gt;</span>
<span class="s1">   &lt;meta content=&quot;text/html; charset=ISO-Latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="s1">  &lt;/head&gt;</span>
<span class="s1">  &lt;body&gt;</span>
<span class="s1">   &lt;p&gt;Sacr</span><span class="se">\xe9</span><span class="s1"> bleu!&lt;/p&gt;</span>
<span class="s1">  &lt;/body&gt;</span>
<span class="s1"> &lt;/html&gt;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Sacré bleu!</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Note that the &lt;meta&gt; tag has been rewritten to reflect the fact that
the document is now in UTF-8.</p>
<p>If you don’t want UTF-8, you can pass an encoding into <code class="docutils literal notranslate"><span class="pre">prettify()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>You can also call encode() on the <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> object, or any
element in the soup, just as if it were a Python string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">)</span>
<span class="c1"># &#39;&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="c1"># &#39;&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>Any characters that can’t be represented in your chosen encoding will
be converted into numeric XML entity references. Here’s a document
that includes the Unicode character SNOWMAN:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;&lt;b&gt;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&lt;/b&gt;&quot;</span>
<span class="n">snowman_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">snowman_soup</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>The SNOWMAN character can be part of a UTF-8 document (it looks like
☃), but there’s no representation for that character in ISO-Latin-1 or
ASCII, so it’s converted into «&amp;#9731» for those encodings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
<span class="c1"># &lt;b&gt;☃&lt;/b&gt;</span>

<span class="nb">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">)</span>
<span class="c1"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span>

<span class="nb">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
<span class="c1"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="unicode-dammit">
<h2>Unicode, Dammit<a class="headerlink" href="#unicode-dammit" title="Ссылка на этот заголовок">¶</a></h2>
<p>You can use Unicode, Dammit without using Beautiful Soup. It’s useful
whenever you have data in an unknown encoding and you just want it to
become Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">UnicodeDammit</span>
<span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">&quot;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># Sacré bleu!</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;utf-8&#39;</span>
</pre></div>
</div>
<p>Unicode, Dammit’s guesses will get a lot more accurate if you install
the <code class="docutils literal notranslate"><span class="pre">chardet</span></code> or <code class="docutils literal notranslate"><span class="pre">cchardet</span></code> Python libraries. The more data you
give Unicode, Dammit, the more accurately it will guess. If you have
your own suspicions as to what the encoding might be, you can pass
them in as a list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">&quot;Sacr</span><span class="se">\xe9</span><span class="s2"> bleu!&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;latin-1&quot;</span><span class="p">,</span> <span class="s2">&quot;iso-8859-1&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># Sacré bleu!</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;latin-1&#39;</span>
</pre></div>
</div>
<p>Unicode, Dammit has two special features that Beautiful Soup doesn’t
use.</p>
<div class="section" id="smart-quotes">
<h3>Smart quotes<a class="headerlink" href="#smart-quotes" title="Ссылка на этот заголовок">¶</a></h3>
<p>You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML
entities:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&lt;p&gt;I just </span><span class="se">\x93</span><span class="s2">love</span><span class="se">\x94</span><span class="s2"> Microsoft Word</span><span class="se">\x92</span><span class="s2">s smart quotes&lt;/p&gt;&quot;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;&#39;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>You can also convert Microsoft smart quotes to ASCII quotes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &quot;love&quot; Microsoft Word\&#39;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>Hopefully you’ll find this feature useful, but Beautiful Soup doesn’t
use it. Beautiful Soup prefers the default behavior, which is to
convert Microsoft smart quotes to Unicode characters along with
everything else:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just \u201clove\u201d Microsoft Word\u2019s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="inconsistent-encodings">
<h3>Inconsistent encodings<a class="headerlink" href="#inconsistent-encodings" title="Ссылка на этот заголовок">¶</a></h3>
<p>Sometimes a document is mostly in UTF-8, but contains Windows-1252
characters such as (again) Microsoft smart quotes. This can happen
when a website includes data from multiple sources. You can use
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> to turn such a document into pure
UTF-8. Here’s a simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">snowmen</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">quote</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="se">\N{LEFT DOUBLE QUOTATION MARK}</span><span class="s2">I like snowmen!</span><span class="se">\N{RIGHT DOUBLE QUOTATION MARK}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">snowmen</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">quote</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;windows_1252&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This document is a mess. The snowmen are in UTF-8 and the quotes are
in Windows-1252. You can display the snowmen or the quotes, but not
both:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="c1"># ☃☃☃�I like snowmen!�</span>

<span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">))</span>
<span class="c1"># â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</span>
</pre></div>
</div>
<p>Decoding the document as UTF-8 raises a <code class="docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code>, and
decoding it as Windows-1252 gives you gibberish. Fortunately,
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> will convert the string to pure UTF-8,
allowing you to decode it to Unicode and display the snowmen and quote
marks simultaneously:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_doc</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="o">.</span><span class="n">detwingle</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span>
<span class="c1"># ☃☃☃“I like snowmen!”</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> only knows how to handle Windows-1252
embedded in UTF-8 (or vice versa, I suppose), but this is the most
common case.</p>
<p>Note that you must know to call <code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> on your
data before passing it into <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> or the <code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code>
constructor. Beautiful Soup assumes that a document has a single
encoding, whatever it might be. If you pass it a document that
contains both UTF-8 and Windows-1252, it’s likely to think the whole
document is Windows-1252, and the document will come out looking like
<code class="docutils literal notranslate"><span class="pre">â˜ƒâ˜ƒâ˜ƒ“I</span> <span class="pre">like</span> <span class="pre">snowmen!”</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> is new in Beautiful Soup 4.1.0.</p>
</div>
</div>
</div>
<div class="section" id="line-numbers">
<h1>Line numbers<a class="headerlink" href="#line-numbers" title="Ссылка на этот заголовок">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">html.parser`</span> <span class="pre">and</span> <span class="pre">``html5lib</span></code> parsers can keep track of where in
the original document each Tag was found. You can access this
information as <code class="docutils literal notranslate"><span class="pre">Tag.sourceline</span></code> (line number) and <code class="docutils literal notranslate"><span class="pre">Tag.sourcepos</span></code>
(position of the start tag within a line):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># (1, 0, u&#39;Paragraph 1&#39;)</span>
<span class="c1"># (2, 3, u&#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>Note that the two parsers mean slightly different things by
<code class="docutils literal notranslate"><span class="pre">sourceline</span></code> and <code class="docutils literal notranslate"><span class="pre">sourcepos</span></code>. For html.parser, these numbers
represent the position of the initial less-than sign. For html5lib,
these numbers represent the position of the final greater-than sign:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html5lib&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># (2, 1, u&#39;Paragraph 1&#39;)</span>
<span class="c1"># (3, 7, u&#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>You can shut off this feature by passing <code class="docutils literal notranslate"><span class="pre">store_line_numbers=False`</span>
<span class="pre">into</span> <span class="pre">the</span> <span class="pre">``BeautifulSoup</span></code> constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">store_line_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">sourceline</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>This feature is new in 4.8.1, and the parsers based on lxml don’t
support it.</p>
</div>
<div class="section" id="comparing-objects-for-equality">
<h1>Comparing objects for equality<a class="headerlink" href="#comparing-objects-for-equality" title="Ссылка на этот заголовок">¶</a></h1>
<p>Beautiful Soup says that two <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> or <code class="docutils literal notranslate"><span class="pre">Tag</span></code> objects
are equal when they represent the same HTML or XML markup. In this
example, the two &lt;b&gt; tags are treated as equal, even though they live
in different parts of the object tree, because they both look like
«&lt;b&gt;pizza&lt;/b&gt;»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">first_b</span><span class="p">,</span> <span class="n">second_b</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">first_b</span> <span class="o">==</span> <span class="n">second_b</span>
<span class="c1"># True</span>

<span class="nb">print</span> <span class="n">first_b</span><span class="o">.</span><span class="n">previous_element</span> <span class="o">==</span> <span class="n">second_b</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>If you want to see whether two variables refer to exactly the same
object, use <cite>is</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">first_b</span> <span class="ow">is</span> <span class="n">second_b</span>
<span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="section" id="copying-beautiful-soup-objects">
<h1>Copying Beautiful Soup objects<a class="headerlink" href="#copying-beautiful-soup-objects" title="Ссылка на этот заголовок">¶</a></h1>
<p>You can use <code class="docutils literal notranslate"><span class="pre">copy.copy()</span></code> to create a copy of any <code class="docutils literal notranslate"><span class="pre">Tag</span></code> or
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">p_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">p_copy</span>
<span class="c1"># &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</span>
</pre></div>
</div>
<p>The copy is considered equal to the original, since it represents the
same markup as the original, but it’s not the same object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">p_copy</span>
<span class="c1"># True</span>

<span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="n">p_copy</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>The only real difference is that the copy is completely detached from
the original Beautiful Soup object tree, just as if <code class="docutils literal notranslate"><span class="pre">extract()</span></code> had
been called on it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">p_copy</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>This is because two different <code class="docutils literal notranslate"><span class="pre">Tag</span></code> objects can’t occupy the same
space at the same time.</p>
</div>
<div class="section" id="parsing-only-part-of-a-document">
<h1>Parsing only part of a document<a class="headerlink" href="#parsing-only-part-of-a-document" title="Ссылка на этот заголовок">¶</a></h1>
<p>Let’s say you want to use Beautiful Soup look at a document’s &lt;a&gt;
tags. It’s a waste of time and memory to parse the entire document and
then go over it again looking for &lt;a&gt; tags. It would be much faster to
ignore everything that wasn’t an &lt;a&gt; tag in the first place. The
<code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> class allows you to choose which parts of an incoming
document are parsed. You just create a <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> and pass it in
to the <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor as the <code class="docutils literal notranslate"><span class="pre">parse_only</span></code> argument.</p>
<p>(Note that <em>this feature won’t work if you’re using the html5lib parser</em>.
If you use html5lib, the whole document will be parsed, no
matter what. This is because html5lib constantly rearranges the parse
tree as it works, and if some part of the document didn’t actually
make it into the parse tree, it’ll crash. To avoid confusion, in the
examples below I’ll be forcing Beautiful Soup to use Python’s
built-in parser.)</p>
<div class="section" id="soupstrainer">
<h2><code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code><a class="headerlink" href="#soupstrainer" title="Ссылка на этот заголовок">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> class takes the same arguments as a typical
method from <a href="#id64"><span class="problematic" id="id65">`Searching the tree`_</span></a>: <a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, and <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>. Here are
three <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">SoupStrainer</span>

<span class="n">only_a_tags</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

<span class="n">only_tags_with_id_link2</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_short_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>

<span class="n">only_short_strings</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_short_string</span><span class="p">)</span>
</pre></div>
</div>
<p>I’m going to bring back the «three sisters» document one more time,
and we’ll see what the document looks like when it’s parsed with these
three <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_a_tags</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#  Elsie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span>
<span class="c1">#  Tillie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_tags_with_id_link2</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_short_strings</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># Elsie</span>
<span class="c1"># ,</span>
<span class="c1"># Lacie</span>
<span class="c1"># and</span>
<span class="c1"># Tillie</span>
<span class="c1"># ...</span>
<span class="c1">#</span>
</pre></div>
</div>
<p>You can also pass a <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> into any of the methods covered
in <a href="#id66"><span class="problematic" id="id67">`Searching the tree`_</span></a>. This probably isn’t terribly useful, but I
thought I’d mention it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">only_short_strings</span><span class="p">)</span>
<span class="c1"># [u&#39;\n\n&#39;, u&#39;\n\n&#39;, u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c1">#  u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="troubleshooting">
<h1>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="diagnose">
<span id="id53"></span><h2><code class="docutils literal notranslate"><span class="pre">diagnose()</span></code><a class="headerlink" href="#diagnose" title="Ссылка на этот заголовок">¶</a></h2>
<p>If you’re having trouble understanding what Beautiful Soup does to a
document, pass the document into the <code class="docutils literal notranslate"><span class="pre">diagnose()</span></code> function. (New in
Beautiful Soup 4.2.0.)  Beautiful Soup will print out a report showing
you how different parsers handle the document, and tell you if you’re
missing a parser that Beautiful Soup could be using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.diagnose</span> <span class="kn">import</span> <span class="n">diagnose</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;bad.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">diagnose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Diagnostic running on Beautiful Soup 4.2.0</span>
<span class="c1"># Python version 2.7.3 (default, Aug  1 2012, 05:16:07)</span>
<span class="c1"># I noticed that html5lib is not installed. Installing it may help.</span>
<span class="c1"># Found lxml version 2.3.2.0</span>
<span class="c1">#</span>
<span class="c1"># Trying to parse your data with html.parser</span>
<span class="c1"># Here&#39;s what html.parser did with the document:</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>Just looking at the output of diagnose() may show you how to solve the
problem. Even if not, you can paste the output of <code class="docutils literal notranslate"><span class="pre">diagnose()</span></code> when
asking for help.</p>
</div>
<div class="section" id="errors-when-parsing-a-document">
<h2>Errors when parsing a document<a class="headerlink" href="#errors-when-parsing-a-document" title="Ссылка на этот заголовок">¶</a></h2>
<p>There are two different kinds of parse errors. There are crashes,
where you feed a document to Beautiful Soup and it raises an
exception, usually an <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError</span></code>. And there is
unexpected behavior, where a Beautiful Soup parse tree looks a lot
different than the document used to create it.</p>
<p>Almost none of these problems turn out to be problems with Beautiful
Soup. This is not because Beautiful Soup is an amazingly well-written
piece of software. It’s because Beautiful Soup doesn’t include any
parsing code. Instead, it relies on external parsers. If one parser
isn’t working on a certain document, the best solution is to try a
different parser. See <a href="#id68"><span class="problematic" id="id69">`Installing a parser`_</span></a> for details and a parser
comparison.</p>
<p>The most common parse errors are <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span>
<span class="pre">malformed</span> <span class="pre">start</span> <span class="pre">tag</span></code> and <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">bad</span> <span class="pre">end</span>
<span class="pre">tag</span></code>. These are both generated by Python’s built-in HTML parser
library, and the solution is to <a class="reference internal" href="#parser-installation"><span class="std std-ref">install lxml or
html5lib.</span></a></p>
<p>The most common type of unexpected behavior is that you can’t find a
tag that you know is in the document. You saw it going in, but
<code class="docutils literal notranslate"><span class="pre">find_all()</span></code> returns <code class="docutils literal notranslate"><span class="pre">[]</span></code> or <code class="docutils literal notranslate"><span class="pre">find()</span></code> returns <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is
another common problem with Python’s built-in HTML parser, which
sometimes skips tags it doesn’t understand.  Again, the solution is to
<a class="reference internal" href="#parser-installation"><span class="std std-ref">install lxml or html5lib.</span></a></p>
</div>
<div class="section" id="version-mismatch-problems">
<h2>Version mismatch problems<a class="headerlink" href="#version-mismatch-problems" title="Ссылка на этот заголовок">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SyntaxError:</span> <span class="pre">Invalid</span> <span class="pre">syntax</span></code> (on the line <code class="docutils literal notranslate"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span>
<span class="pre">u'[document]'</span></code>): Caused by running the Python 2 version of
Beautiful Soup under Python 3, without converting the code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">HTMLParser</span></code> - Caused by running the
Python 2 version of Beautiful Soup under Python 3.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">html.parser</span></code> - Caused by running the
Python 3 version of Beautiful Soup under Python 2.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">BeautifulSoup</span></code> - Caused by running
Beautiful Soup 3 code on a system that doesn’t have BS3
installed. Or, by writing Beautiful Soup 4 code without knowing that
the package name has changed to <code class="docutils literal notranslate"><span class="pre">bs4</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">bs4</span></code> - Caused by running Beautiful
Soup 4 code on a system that doesn’t have BS4 installed.</p></li>
</ul>
</div>
<div class="section" id="parsing-xml">
<span id="id54"></span><h2>Parsing XML<a class="headerlink" href="#parsing-xml" title="Ссылка на этот заголовок">¶</a></h2>
<p>By default, Beautiful Soup parses documents as HTML. To parse a
document as XML, pass in «xml» as the second argument to the
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You’ll need to <a class="reference internal" href="#parser-installation"><span class="std std-ref">have lxml installed</span></a>.</p>
</div>
<div class="section" id="other-parser-problems">
<h2>Other parser problems<a class="headerlink" href="#other-parser-problems" title="Ссылка на этот заголовок">¶</a></h2>
<ul class="simple">
<li><p>If your script works on one computer but not another, or in one
virtual environment but not another, or outside the virtual
environment but not inside, it’s probably because the two
environments have different parser libraries available. For example,
you may have developed the script on a computer that has lxml
installed, and then tried to run it on a computer that only has
html5lib installed. See <a href="#id70"><span class="problematic" id="id71">`Differences between parsers`_</span></a> for why this
matters, and fix the problem by mentioning a specific parser library
in the <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor.</p></li>
<li><p>Because <a class="reference external" href="http://www.w3.org/TR/html5/syntax.html#syntax">HTML tags and attributes are case-insensitive</a>, all three HTML
parsers convert tag and attribute names to lowercase. That is, the
markup &lt;TAG&gt;&lt;/TAG&gt; is converted to &lt;tag&gt;&lt;/tag&gt;. If you want to
preserve mixed-case or uppercase tags and attributes, you’ll need to
<a class="reference internal" href="#parsing-xml"><span class="std std-ref">parse the document as XML.</span></a></p></li>
</ul>
</div>
<div class="section" id="miscellaneous">
<span id="misc"></span><h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Ссылка на этот заголовок">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'charmap'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span>
<span class="pre">u'\xfoo'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">bar</span></code> (or just about any other
<code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code>) - This is not a problem with Beautiful Soup.
This problem shows up in two main situations. First, when you try to
print a Unicode character that your console doesn’t know how to
display. (See <a class="reference external" href="http://wiki.python.org/moin/PrintFails">this page on the Python wiki</a> for help.) Second, when
you’re writing to a file and you pass in a Unicode character that’s
not supported by your default encoding.  In this case, the simplest
solution is to explicitly encode the Unicode string into UTF-8 with
<code class="docutils literal notranslate"><span class="pre">u.encode(&quot;utf8&quot;)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">[attr]</span></code> - Caused by accessing <code class="docutils literal notranslate"><span class="pre">tag['attr']</span></code> when the
tag in question doesn’t define the <code class="docutils literal notranslate"><span class="pre">attr</span></code> attribute. The most
common errors are <code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">'href'</span></code> and <code class="docutils literal notranslate"><span class="pre">KeyError:</span>
<span class="pre">'class'</span></code>. Use <code class="docutils literal notranslate"><span class="pre">tag.get('attr')</span></code> if you’re not sure <code class="docutils literal notranslate"><span class="pre">attr</span></code> is
defined, just as you would with a Python dictionary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'ResultSet'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> - This
usually happens because you expected <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> to return a
single tag or string. But <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> returns a _list_ of tags
and strings–a <code class="docutils literal notranslate"><span class="pre">ResultSet</span></code> object. You need to iterate over the
list and look at the <code class="docutils literal notranslate"><span class="pre">.foo</span></code> of each one. Or, if you really only
want one result, you need to use <code class="docutils literal notranslate"><span class="pre">find()</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">find_all()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'NoneType'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> - This
usually happens because you called <code class="docutils literal notranslate"><span class="pre">find()</span></code> and then tried to
access the <cite>.foo`</cite> attribute of the result. But in your case,
<code class="docutils literal notranslate"><span class="pre">find()</span></code> didn’t find anything, so it returned <code class="docutils literal notranslate"><span class="pre">None</span></code>, instead of
returning a tag or a string. You need to figure out why your
<code class="docutils literal notranslate"><span class="pre">find()</span></code> call isn’t returning anything.</p></li>
</ul>
</div>
<div class="section" id="improving-performance">
<h2>Improving Performance<a class="headerlink" href="#improving-performance" title="Ссылка на этот заголовок">¶</a></h2>
<p>Beautiful Soup will never be as fast as the parsers it sits on top
of. If response time is critical, if you’re paying for computer time
by the hour, or if there’s any other reason why computer time is more
valuable than programmer time, you should forget about Beautiful Soup
and work directly atop <a class="reference external" href="http://lxml.de/">lxml</a>.</p>
<p>That said, there are things you can do to speed up Beautiful Soup. If
you’re not using lxml as the underlying parser, my advice is to
<a class="reference internal" href="#parser-installation"><span class="std std-ref">start</span></a>. Beautiful Soup parses documents
significantly faster using lxml than using html.parser or html5lib.</p>
<p>You can speed up encoding detection significantly by installing the
<a class="reference external" href="http://pypi.python.org/pypi/cchardet/">cchardet</a> library.</p>
<p><a class="reference internal" href="#parsing-only-part-of-a-document">Parsing only part of a document</a> won’t save you much time parsing
the document, but it can save a lot of memory, and it’ll make
<cite>searching</cite> the document much faster.</p>
</div>
</div>
<div class="section" id="translating-this-documentation">
<h1>Translating this documentation<a class="headerlink" href="#translating-this-documentation" title="Ссылка на этот заголовок">¶</a></h1>
<p>New translations of the Beautiful Soup documentation are greatly
appreciated. Translations should be licensed under the MIT license,
just like Beautiful Soup and its English documentation are.</p>
<p>There are two ways of getting your translation into the main code base
and onto the Beautiful Soup website:</p>
<ol class="arabic simple">
<li><p>Create a branch of the Beautiful Soup repository, add your
translation, and propose a merge with the main branch, the same
as you would do with a proposed change to the source code.</p></li>
<li><p>Send a message to the Beautiful Soup discussion group with a link to
your translation, or attach your translation to the message.</p></li>
</ol>
<p>Use the Chinese or Brazilian Portuguese translations as your model. In
particular, please translate the source file <code class="docutils literal notranslate"><span class="pre">doc/source/index.rst</span></code>,
rather than the HTML version of the documentation. This makes it
possible to publish the documentation in a variety of formats, not
just HTML.</p>
</div>
<div class="section" id="id56">
<h1>Beautiful Soup 3<a class="headerlink" href="#id56" title="Ссылка на этот заголовок">¶</a></h1>
<p>Beautiful Soup 3 is the previous release series, and is no longer
being actively developed. It’s currently packaged with all major Linux
distributions:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-beautifulsoup</kbd></p>
<p>It’s also published through PyPi as <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>.:</p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install BeautifulSoup</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install BeautifulSoup</kbd></p>
<p>You can also <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz">download a tarball of Beautiful Soup 3.2.0</a>.</p>
<p>If you ran <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup</span></code> or <code class="docutils literal notranslate"><span class="pre">easy_install</span>
<span class="pre">BeautifulSoup</span></code>, but your code doesn’t work, you installed Beautiful
Soup 3 by mistake. You need to run <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup4</span></code>.</p>
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">The documentation for Beautiful Soup 3 is archived online</a>.</p>
<div class="section" id="porting-code-to-bs4">
<h2>Porting code to BS4<a class="headerlink" href="#porting-code-to-bs4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Most code written against Beautiful Soup 3 will work against Beautiful
Soup 4 with one simple change. All you should have to do is change the
package name from <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> to <code class="docutils literal notranslate"><span class="pre">bs4</span></code>. So this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">BeautifulSoup</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<p>becomes this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If you get the <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> «No module named BeautifulSoup», your
problem is that you’re trying to run Beautiful Soup 3 code, but you
only have Beautiful Soup 4 installed.</p></li>
<li><p>If you get the <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> «No module named bs4», your problem
is that you’re trying to run Beautiful Soup 4 code, but you only
have Beautiful Soup 3 installed.</p></li>
</ul>
<p>Although BS4 is mostly backwards-compatible with BS3, most of its
methods have been deprecated and given new names for <a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">PEP 8 compliance</a>. There are numerous other
renames and changes, and a few of them break backwards compatibility.</p>
<p>Here’s what you’ll need to know to convert your BS3 code and habits to BS4:</p>
<div class="section" id="you-need-a-parser">
<h3>You need a parser<a class="headerlink" href="#you-need-a-parser" title="Ссылка на этот заголовок">¶</a></h3>
<p>Beautiful Soup 3 used Python’s <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code>, a module that was
deprecated and removed in Python 3.0. Beautiful Soup 4 uses
<code class="docutils literal notranslate"><span class="pre">html.parser</span></code> by default, but you can plug in lxml or html5lib and
use that instead. See <a href="#id72"><span class="problematic" id="id73">`Installing a parser`_</span></a> for a comparison.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> is not the same parser as <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code>, you
may find that Beautiful Soup 4 gives you a different parse tree than
Beautiful Soup 3 for the same markup. If you swap out <code class="docutils literal notranslate"><span class="pre">html.parser</span></code>
for lxml or html5lib, you may find that the parse tree changes yet
again. If this happens, you’ll need to update your scraping code to
deal with the new tree.</p>
</div>
<div class="section" id="method-names">
<h3>Method names<a class="headerlink" href="#method-names" title="Ссылка на этот заголовок">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">renderContents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">encode_contents</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">replaceWith</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">replace_with</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">replaceWithChildren</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">unwrap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAll</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAllNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_next</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAllPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_previous</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNextSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findParent</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parent</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findParents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parents</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPreviousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPreviousSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">getText</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">get_text</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_sibling</span></code></p></li>
</ul>
<p>Some arguments to the Beautiful Soup constructor were renamed for the
same reasons:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parseOnlyThese=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parse_only=...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(fromEncoding=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(from_encoding=...)</span></code></p></li>
</ul>
<p>I renamed one method for compatibility with Python 3:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.has_key()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.has_attr()</span></code></p></li>
</ul>
<p>I renamed one attribute to use more accurate terminology:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.isSelfClosing</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.is_empty_element</span></code></p></li>
</ul>
<p>I renamed three attributes to avoid using words that have special
meaning to Python. Unlike the others, these changes are <em>not backwards
compatible.</em> If you used these attributes in BS3, your code will break
on BS4 until you change them.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.unicode</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">UnicodeDammit.unicode_markup</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.next</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.next_element</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.previous</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.previous_element</span></code></p></li>
</ul>
</div>
<div class="section" id="generators">
<h3>Generators<a class="headerlink" href="#generators" title="Ссылка на этот заголовок">¶</a></h3>
<p>I gave the generators PEP 8-compliant names, and transformed them into
properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">childGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">children</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_elements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_elements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">recursiveChildGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">descendants</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parentGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">parents</span></code></p></li>
</ul>
<p>So instead of this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parentGenerator</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>You can write this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>(But the old code will still work.)</p>
<p>Some of the generators used to yield <code class="docutils literal notranslate"><span class="pre">None</span></code> after they were done, and
then stop. That was a bug. Now the generators just stop.</p>
<p>There are two new generators, <a class="reference internal" href="#string-generators"><span class="std std-ref">.strings and
.stripped_strings</span></a>. <code class="docutils literal notranslate"><span class="pre">.strings</span></code> yields
NavigableString objects, and <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code> yields Python
strings that have had whitespace stripped.</p>
</div>
<div class="section" id="xml">
<h3>XML<a class="headerlink" href="#xml" title="Ссылка на этот заголовок">¶</a></h3>
<p>There is no longer a <code class="docutils literal notranslate"><span class="pre">BeautifulStoneSoup</span></code> class for parsing XML. To
parse XML you pass in «xml» as the second argument to the
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor. For the same reason, the
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor no longer recognizes the <code class="docutils literal notranslate"><span class="pre">isHTML</span></code>
argument.</p>
<p>Beautiful Soup’s handling of empty-element XML tags has been
improved. Previously when you parsed XML you had to explicitly say
which tags were considered empty-element tags. The <code class="docutils literal notranslate"><span class="pre">selfClosingTags</span></code>
argument to the constructor is no longer recognized. Instead,
Beautiful Soup considers any empty tag to be an empty-element tag. If
you add a child to an empty-element tag, it stops being an
empty-element tag.</p>
</div>
<div class="section" id="entities">
<h3>Entities<a class="headerlink" href="#entities" title="Ссылка на этот заголовок">¶</a></h3>
<p>An incoming HTML or XML entity is always converted into the
corresponding Unicode character. Beautiful Soup 3 had a number of
overlapping ways of dealing with entities, which have been
removed. The <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor no longer recognizes the
<code class="docutils literal notranslate"><span class="pre">smartQuotesTo</span></code> or <code class="docutils literal notranslate"><span class="pre">convertEntities</span></code> arguments. (<a class="reference internal" href="#unicode-dammit">Unicode,
Dammit</a> still has <code class="docutils literal notranslate"><span class="pre">smart_quotes_to</span></code>, but its default is now to turn
smart quotes into Unicode.) The constants <code class="docutils literal notranslate"><span class="pre">HTML_ENTITIES</span></code>,
<code class="docutils literal notranslate"><span class="pre">XML_ENTITIES</span></code>, and <code class="docutils literal notranslate"><span class="pre">XHTML_ENTITIES</span></code> have been removed, since they
configure a feature (transforming some but not all entities into
Unicode characters) that no longer exists.</p>
<p>If you want to turn Unicode characters back into HTML entities on
output, rather than turning them into UTF-8 characters, you need to
use an <a class="reference internal" href="#output-formatters"><span class="std std-ref">output formatter</span></a>.</p>
</div>
<div class="section" id="id57">
<h3>Miscellaneous<a class="headerlink" href="#id57" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference internal" href="#string"><span class="std std-ref">Tag.string</span></a> now operates recursively. If tag A
contains a single tag B and nothing else, then A.string is the same as
B.string. (Previously, it was None.)</p>
<p><a href="#id74"><span class="problematic" id="id75">`Multi-valued attributes`_</span></a> like <code class="docutils literal notranslate"><span class="pre">class</span></code> have lists of strings as
their values, not strings. This may affect the way you search by CSS
class.</p>
<p>If you pass one of the <code class="docutils literal notranslate"><span class="pre">find*</span></code> methods both <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a> <cite>and</cite>
a tag-specific argument like <a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, Beautiful Soup will
search for tags that match your tag-specific criteria and whose
<a class="reference internal" href="#string"><span class="std std-ref">Tag.string</span></a> matches your value for <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>. It will <cite>not</cite> find the strings themselves. Previously,
Beautiful Soup ignored the tag-specific arguments and looked for
strings.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> constructor no longer recognizes the
<cite>markupMassage</cite> argument. It’s now the parser’s responsibility to
handle markup correctly.</p>
<p>The rarely-used alternate parser classes like
<code class="docutils literal notranslate"><span class="pre">ICantBelieveItsBeautifulSoup</span></code> and <code class="docutils literal notranslate"><span class="pre">BeautifulSOAP</span></code> have been
removed. It’s now the parser’s decision how to handle ambiguous
markup.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> method now returns a Unicode string, not a bytestring.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">bs4RU</a></h1>








<h3>Навигация</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Документация Beautiful Soup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id5">Техническая поддержка</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id7">Быстрый старт</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id8">Установка Beautiful Soup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id9">Проблемы после установки</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parser-installation">Установка парсера</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id11">Приготовление супа</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id12">Виды объектов</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tag"><code class="docutils literal notranslate"><span class="pre">Tag</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#navigablestring"><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#beautifulsoup"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">Комментарии и другие специфичные строки</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id18">Навигация по дереву</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id19">Проход сверху вниз</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">Проход снизу вверх</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">Перемещение вбок</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">Проход вперёд и назад</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id27">Поиск по дереву</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id28">Виды фильтров</a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-all"><code class="docutils literal notranslate"><span class="pre">find_all()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">Вызов тега похож на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find"><code class="docutils literal notranslate"><span class="pre">find()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-parents-find-parent"><code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-next-siblings-find-next-sibling"><code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-previous-siblings-find-previous-sibling"><code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous_sibling()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-all-next-find-next"><code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-all-previous-find-previous"><code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">Селекторы CSS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id42">Изменение дерева</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id43">Изменение имен тегов и атрибутов</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">Изменение <code class="docutils literal notranslate"><span class="pre">.string</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#append"><code class="docutils literal notranslate"><span class="pre">append()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#extend"><code class="docutils literal notranslate"><span class="pre">extend()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#navigablestring-new-tag"><code class="docutils literal notranslate"><span class="pre">NavigableString()</span></code> и <code class="docutils literal notranslate"><span class="pre">.new_tag()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#insert"><code class="docutils literal notranslate"><span class="pre">insert()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#insert-before-insert-after"><code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> и <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#clear"><code class="docutils literal notranslate"><span class="pre">clear()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#extract"><code class="docutils literal notranslate"><span class="pre">extract()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#decompose"><code class="docutils literal notranslate"><span class="pre">decompose()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#replace-with"><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wrap"><code class="docutils literal notranslate"><span class="pre">wrap()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#unwrap"><code class="docutils literal notranslate"><span class="pre">unwrap()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#smooth"><code class="docutils literal notranslate"><span class="pre">smooth()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id46">Вывод</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prettyprinting">Красивое форматирование</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id48">Без красивого форматирования</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-formatters">Средства форматирования вывода</a></li>
<li class="toctree-l2"><a class="reference internal" href="#get-text"><code class="docutils literal notranslate"><span class="pre">get_text()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id50">Указание парсера</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id51">Различия между парсерами</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id52">Кодировки</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#output-encoding">Output encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unicode-dammit">Unicode, Dammit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#line-numbers">Line numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="#comparing-objects-for-equality">Comparing objects for equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="#copying-beautiful-soup-objects">Copying Beautiful Soup objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="#parsing-only-part-of-a-document">Parsing only part of a document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#soupstrainer"><code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#troubleshooting">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#diagnose"><code class="docutils literal notranslate"><span class="pre">diagnose()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#errors-when-parsing-a-document">Errors when parsing a document</a></li>
<li class="toctree-l2"><a class="reference internal" href="#version-mismatch-problems">Version mismatch problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parsing-xml">Parsing XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-parser-problems">Other parser problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="#improving-performance">Improving Performance</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#translating-this-documentation">Translating this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id56">Beautiful Soup 3</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#porting-code-to-bs4">Porting code to BS4</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="предыдущая глава">Welcome to bs4RUdocs’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Leonard Richardson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/bs4_source_ru.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>